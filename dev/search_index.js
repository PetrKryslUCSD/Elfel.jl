var documenterSearchIndex = {"docs":
[{"location":"tutorials/tut_poisson_q4.html#Solve-the-heat-conduction-equation","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"","category":"section"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Synopsis: Compute the solution of the Poisson equation of heat conduction with a nonzero heat source. Quadrilateral four-node elements are used.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The problem is linear heat conduction equation posed on a bi-unit square, solved with Dirichlet boundary conditions around the circumference. Uniform nonzero heat generation rate is present. The exact solution is in this way manufactured and hence known. That gives us an opportunity to calculate the true error.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The complete code is in the file tut_poisson_q4.jl.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"module tut_poisson_q4","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"We'll need some functionality from linear algebra, and the mesh libraries. Finally we will need the Elfel functionality.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"using LinearAlgebra\nusing MeshCore.Exports\nusing MeshSteward.Exports\nusing Elfel.Exports","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is the top level function.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function run()","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Input parameters:","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    A = 1.0 # length of the side of the square\n    kappa =  1.0; # thermal conductivity of the material\n    Q = -6.0; # internal heat generation rate\n    tempf(x, y) =(1.0 + x^2 + 2.0 * y^2); # the exact distribution of temperature\n    N = 1000; # number of element edges along the sides of the square domain","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Generate the computational mesh.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    mesh = genmesh(A, N)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Create the finite element space to represent the temperature solution. The degrees of freedom are real numbers (Float64), the quadrilaterals are defined by the mesh, and each of the elements has the continuity H ^1, i. e. both the function values and the derivatives are square integrable.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    Uh = FESpace(Float64, mesh, FEH1_Q4())","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Apply the essential boundary conditions at the circumference of the square domain. We find the boundary incidence relation (boundary(mesh)), and then the list of all vertices connected by the boundary cells. The function tempf defines the analytical temperature variation, and hence for each of the vertices i on the boundary (they are of manifold dimension  0), we set the component of the field (1) to the exact value of the temperature at that location.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    vl = connectedv(boundary(mesh));\n    locs = geometry(mesh)\n    for i in vl\n        setebc!(Uh, 0, i, 1, tempf(locs[i]...))\n    end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Number the degrees of freedom, both the unknowns and the data (prescribed) degrees of freedom.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    numberdofs!(Uh)\n    @show ndofs(Uh), nunknowns(Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Assemble the conductivity matrix and the vector of the heat loads. Refer to the definition of this function below.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    K, F = assembleKF(Uh, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is a vector to hold all degrees of freedom in the system.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    T = fill(0.0, ndofs(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Here we collect the data degrees of freedom (the known values).","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    gathersysvec!(T, Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The system of linear algebraic equations is solved.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    solve!(T, K, F, nunknowns(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The values of all the degrees of freedom can now be introduced into the finite element space.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    scattersysvec!(Uh, T)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Here we associate the values of the finite element space with the entities of the mesh as an attribute.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    makeattribute(Uh, \"T\", 1)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The correctness of the solution is checked by comparing the values at the vertices.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    checkcorrectness(Uh, tempf)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The attribute can now be written out for visualization into a VTK file.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    vtkwrite(\"q4-T\", baseincrel(mesh), [(name = \"T\",)])\n\n    true # return success\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The domain is a square, meshed with quadrilateral elements. The function Q4block creates an incidence relation that defines the quadrilateral element shapes by the vertices connected into the shapes. This incidence relation is then attached to the mesh and the mesh is returned.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function genmesh(A, N)\n    conn = Q4block(A, A, N, N)\n    return attach!(Mesh(), conn)\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The assembleKF function constructs the left-hand side coefficient matrix, conductivity matrix, as a sparse matrix, and a vector of the heat loads due to the internal heat generation rate Q.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The boundary value problem is expressed in this weak form","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V\n            -int_V  vartheta Q  mathrmd V\n             = 0","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"where the test function vanishes on the boundary where the temperature is prescribed, vartheta(x) =0  for  x inS_1 Substituting vartheta = N_j and T = sum_i N_i T_i we obtain the linear algebraic equations","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"sum_i T_i int_V mathrmgradN_j  kappa (mathrmgradN_i)^T mathrmd V\n -int_V  N_j Q  mathrmd V  = 0  quad forall j","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The volume element is mathrmd V, which in our case becomes 10timesmathrmd S, since the thickness of the two dimensional domain is assumed to be 1.0.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function assembleKF(Uh, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"At the top of the assembleKF we look at the function integrate! to evaluate the weak-form integrals. The key to making this calculation efficient is type stability. All the arguments coming in must have concrete types. This is why the integrate! function is an inner function: the function barrier allows for all arguments to be resolved to concrete types.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    function integrate!(am, av, elit, qpit, kappa, Q)\n        nedof = ndofsperel(elit)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The local assemblers are just like matrices or vectors","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"        ke = LocalMatrixAssembler(nedof, nedof, 0.0)\n        fe = LocalVectorAssembler(nedof, 0.0)\n        for el in elit # Loop over all elements\n            init!(ke, eldofs(el), eldofs(el)) # zero out elementwise matrix\n            init!(fe, eldofs(el)) # and vector\n            for qp in qpit # Now loop over the quadrature points\n                Jac, J = jacjac(el, qp) # Calculate the Jacobian matrix, Jacobian\n                gradN = bfungrad(qp, Jac) # Evaluate the spatial gradients\n                JxW = J * weight(qp) # elementary volume\n                N = bfun(qp) # Basis function values at the quadrature point","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This double loop evaluates the elementwise conductivity matrix and the heat load vector precisely as the formula of the weak form  dictates; see above.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"                for i in 1:nedof\n                    for j in 1:nedof\n                        ke[j, i] += dot(gradN[j], gradN[i]) * (kappa * JxW)\n                    end\n                    fe[j] += N[j] * Q * JxW\n                end\n            end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Assemble the calculated contributions from this element","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"            assemble!(am, ke)\n            assemble!(av, fe)\n        end\n        return am, av # Return the updated assemblers\n    end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"In the assembleKF function we first we create the element iterator. We can go through all the elements that define the domain of integration using this iterator. Each time a new element is accessed, some data are precomputed such as the element degrees of freedom.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    elit = FEIterator(Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is the quadrature point iterator. We know that the elements are quadrilateral, which makes the Gauss integration rule the obvious choice. We also select order 2 for accuracy. Quadrature-point iterators provide access to basis function values and gradients, the Jacobian matrix and the Jacobian determinant, the location of the quadrature point and so on.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    qpit = QPIterator(Uh, (kind = :Gauss, order = 2))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Next we create assemblers, one for the sparse system matrix and one for the system vector.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    am = start!(SysmatAssemblerSparse(0.0), ndofs(Uh), ndofs(Uh))\n    av = start!(SysvecAssembler(0.0), ndofs(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Now we call the integration function. The assemblers are modified inside this function...","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    @time integrate!(am, av, elit, qpit, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"...so that when the integration is done, we can materialize the sparse matrix and the vector and return them.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    return finish!(am), finish!(av)\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The linear algebraic system is solved by partitioning. The vector T is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the conductivity matrix and the vector T are the heat loads due to nonzero essential boundary conditions. To this we add the vector of heat loads due to the internal heat generation rate. The submatrix of the heat conduction matrix corresponding to the free degrees of freedom (unknowns), K[1:nu, 1:nu] is then used to solve for the unknowns T [1:nu].","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function solve!(T, K, F, nu)\n    @time KT = K * T\n    @time T[1:nu] = K[1:nu, 1:nu] \\ (F[1:nu] - KT[1:nu])\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The correctness can be checked in various ways. Here we calculate the mean deviation of the calculated temperatures at the nodes relative to the exact values of the temperature.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function checkcorrectness(Uh, tempf)\n    geom = geometry(Uh.mesh)\n    ir = baseincrel(Uh.mesh)\n    T = attribute(ir.right, \"T\")\n    std = 0.0\n    for i in 1:length(T)\n        std += abs(T[i][1] - tempf(geom[i]...))\n    end\n    @show (std / length(T)) <= 1.0e-9\nend\n\nend # module","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The module can now be used.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"using .tut_poisson_q4\ntut_poisson_q4.run()","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/reference.html#Reference-manual","page":"Reference","title":"Reference manual","text":"","category":"section"},{"location":"man/reference.html#Reference-shapes","page":"Reference","title":"Reference shapes","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.RefShapes]\nPages   = [\"RefShapes.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.RefShapes.AbstractRefShape","page":"Reference","title":"Elfel.RefShapes.AbstractRefShape","text":"AbstractRefShape{MANIFDIM}\n\nAbstract type of a reference shape.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.IntegRule","page":"Reference","title":"Elfel.RefShapes.IntegRule","text":"IntegRule\n\nType for integration rule.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeCube","page":"Reference","title":"Elfel.RefShapes.RefShapeCube","text":"RefShapeCube <: AbstractRefShape{3}\n\nType of a reference shape for a 3-dimensional manifold (solid) bounded by six quadrilaterals.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeInterval","page":"Reference","title":"Elfel.RefShapes.RefShapeInterval","text":"RefShapeInterval <: AbstractRefShape{1}\n\nType of a reference shape for a 1-dimensional manifold (curve).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapePoint","page":"Reference","title":"Elfel.RefShapes.RefShapePoint","text":"RefShapePoint <: AbstractRefShape{0}\n\nType of a reference shape for a zero-dimensional manifold (point).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeSquare","page":"Reference","title":"Elfel.RefShapes.RefShapeSquare","text":"RefShapeSquare <: AbstractRefShape{2}\n\nType of a logically rectangular reference shape for a 2-dimensional manifold  (surface).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeTetrahedron","page":"Reference","title":"Elfel.RefShapes.RefShapeTetrahedron","text":"RefShapeTetrahedron <: AbstractRefShape{3}\n\nType of a reference shape for a 3-dimensional manifold (solid) bounded by 4 triangles.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeTriangle","page":"Reference","title":"Elfel.RefShapes.RefShapeTriangle","text":"RefShapeTriangle <: AbstractRefShape{2}\n\nType of a logically triangular reference shape for a 2-dimensional manifold  (surface).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.manifdim-Union{Tuple{Type{T}}, Tuple{T}, Tuple{MANIFDIM}} where T<:Elfel.RefShapes.AbstractRefShape{MANIFDIM} where MANIFDIM","page":"Reference","title":"Elfel.RefShapes.manifdim","text":"manifdim(rs)\n\nGet the manifold dimension of the reference shape.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.RefShapes.manifdimv-Union{Tuple{Type{T}}, Tuple{T}, Tuple{MANIFDIM}} where T<:Elfel.RefShapes.AbstractRefShape{MANIFDIM} where MANIFDIM","page":"Reference","title":"Elfel.RefShapes.manifdimv","text":"manifdimv(::Type{T}) where {T<:AbstractRefShape{MANIFDIM}} where {MANIFDIM}\n\nGet the manifold dimension of the reference shape as Val. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.RefShapes.quadrature","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeTriangle}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of an triangle.\n\nThe default is a triangle rule, distinguished by the number of points set with the keyword npts.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-2","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeInterval}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of an interval.\n\nThe default is Gauss integration rule, where the order is set with the keyword order.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-3","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeSquare}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of a square.\n\nThe default is Gauss integration rule, where the order is set with the keyword order.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-4","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeTetrahedron}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of a tetrahedron.\n\nThe default is a one-point tetrahedron rule; other rules may be chosen based on the number of points set with the keyword npts.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elements","page":"Reference","title":"Elements","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FElements]\nPages   = [\"FElements.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FElements.FE","page":"Reference","title":"Elfel.FElements.FE","text":"FE{RS, SD}\n\nAbstract type of finite element, parameterized by\n\nRS: type of reference shape of the element (triangle, square, ...), and\nSD: shape descriptor; refer to the package MeshCore.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FElements.FEData","page":"Reference","title":"Elfel.FElements.FEData","text":"FEData{SD}\n\nType of a finite element data. \n\nParameterized by\n\nSD = shape descriptor; refer to the package MeshCore.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FElements.FEH1_L2-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_L2","text":"FEH1_L2()\n\nConstruct an H1 finite element of the type L2.\n\nL2 is two-node linear segment element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_Q4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_Q4","text":"FEH1_Q4()\n\nConstruct an H1 finite element of the type Q4.\n\nQ4 is 4-node linear quadrilateral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T3-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T3","text":"FEH1_T3()\n\nConstruct an H1 finite element of the type T3.\n\nT3 is 3-node linear triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T3_BUBBLE-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T3_BUBBLE","text":"FEH1_T3_BUBBLE()\n\nConstruct an H1 finite element of the type T3 with a cubic bubble.\n\nT3 is 3-node linear triangle element with a cubic bubble. It has the usual nodal basis functions associated with the vertices, and cubic bubble associated with the element itself.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T4","text":"FEH1_T4()\n\nConstruct an H1 finite element of the type T4.\n\nT4 is 4-node linear tetrahedral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T6-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T6","text":"FEH1_T6()\n\nConstruct an H1 finite element of the type T6.\n\nT6 is 6-node quadratic triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_Q4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_Q4","text":"FEL2_Q4()\n\nConstruct an L2 finite element of the type Q4.\n\nQ4 is 4-node linear quadrilateral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_T3-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_T3","text":"FEL2_T3()\n\nConstruct an L2 finite element of the type T3.\n\nT3 is 3-node linear triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_T4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_T4","text":"FEL2_T4()\n\nConstruct an L2 finite element of the type T4.\n\nT4 is tetrahedral element with only internal degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{0},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{0}, J::T) where {T}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix, which isn't really defined well for a 0-manifold.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{1},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{1}, J::T) where {T}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{2},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{2}, J::T) where {T}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{3},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet3Manifold}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfun-Union{Tuple{FESUBT}, Tuple{SD}, Tuple{RS}, Tuple{FESUBT,Any}} where FESUBT<:Elfel.FElements.FE{RS,SD} where SD where RS","page":"Reference","title":"Elfel.FElements.bfun","text":"bfun(self::FESUBT,  param_coords)  where {FESUBT<:FE{RS, SD}}\n\nEvaluate the basis functions for all degrees of freedom of the scalar finite element at the parametric coordinates. Return a vector of the values.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfungradpar-Union{Tuple{FESUBT}, Tuple{SD}, Tuple{RS}, Tuple{FESUBT,Any}} where FESUBT<:Elfel.FElements.FE{RS,SD} where SD where RS","page":"Reference","title":"Elfel.FElements.bfungradpar","text":"bfungradpar(self::FESUBT,  param_coords)  where {FESUBT<:FE{RS, SD}}\n\nEvaluate the gradients of the basis functions for all degrees of freedom of the scalar finite element with respect to the parametric coordinates, at the parametric coordinates given. Return a vector of the gradients.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.jacjac-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any,Any,Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.jacjac","text":"jacjac(fe::FE{RS, SD}, locs, nodes, gradNpar) where {RS, SD}\n\nCompute the Jacobian matrix and the Jacobian determinant.\n\nThis is the generic version suitable for isoparametric elements.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofperfeat-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.ndofperfeat","text":"feathasdof(fe::FE{RS, SD}, m) where {RS, SD}\n\nHow many degrees of freedom are attached to a the feature of manifold dimension m?\n\nNote that 0 <= m <= 3.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(fe::FE{RS, SD}) where {RS, SD}\n\nProvide the number of degrees of freedom per element.\n\nEnumerate all features of all manifold dimensions, and for each feature multiply by the number of degrees of freedom per feature. The assumption is that this is a scalar finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.nfeatofdim-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.nfeatofdim","text":"nfeatofdim(fe::FE{RS, SD}, m) where {RS, SD}\n\nNumber of features of manifold dimension m. Note that 0 <= m <= 3.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.refshape-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.refshape","text":"refshape(fe::FE{RS, SD}) where {RS, SD}\n\nReference shape.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.shapedesc-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.shapedesc","text":"shapedesc(fe::FE{RS, SD}) where {RS, SD}\n\nTopological shape description.\n\nRefer to the MeshCore library.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#MeshCore.manifdim-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"MeshCore.manifdim","text":"manifdim(fe::FE{RS, SD}) where {RS, SD}\n\nGet the manifold dimension of the finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Spaces","page":"Reference","title":"Spaces","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FESpaces]\nPages   = [\"FESpaces.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FESpace","text":"FESpace{FET, T}\n\nType of a finite element space, parameterized with\n\nFET: type of finite element, it is a scalar finite element, \nT: type of degree of freedom value (double, complex, ...).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,AbstractArray{T,1} where T}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(v, fesp)\n\nGather values for the whole system vector from all FE spaces contributing to it.\n\nfesp is either a vector or a tuple of FE spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,Elfel.FESpaces.FESpace}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(v, fesp::FESpace)\n\nGather values for the whole system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestdatadofnum-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.highestdatadofnum","text":"highestfreedofnum(fesp::FES)  where {FES<:FESpace}\n\nCompute the highest number of data (known) degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestfreedofnum-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.highestfreedofnum","text":"highestfreedofnum(fesp::FES)  where {FES<:FESpace}\n\nCompute the highest number of free (unknown) degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofs-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofs","text":"ndofs(fesp::FES)  where {FES<:FESpace}\n\nCompute the total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberdatadofs!-Union{Tuple{FES}, Tuple{FES}, Tuple{FES,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.numberdatadofs!","text":"numberdatadofs!(fesp::FES, firstnum = 1)  where {FES<:FESpace}\n\nNumber the data (known) degrees of freedom.\n\nThe known degrees of freedom in the FE space are numbered consecutively. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberfreedofs!-Union{Tuple{FES}, Tuple{FES}, Tuple{FES,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.numberfreedofs!","text":"numberfreedofs!(fesp::FES, firstnum = 1)  where {FES<:FESpace}\n\nNumber the free degrees of freedom.\n\nThe unknown degrees of freedom in the FE space are numbered consecutively. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{AbstractArray{T,1} where T,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(fesp, v)\n\nScatter values for the whole system vector to all FE spaces contributing to it.\n\nfesp is either a vector or a tuple of FE spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{Elfel.FESpaces.FESpace,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(fesp::FESpace, v)\n\nScatter values from the system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.setebc!-Union{Tuple{T}, Tuple{Elfel.FESpaces.FESpace,Any,Any,Any,T}} where T","page":"Reference","title":"Elfel.FESpaces.FEFields.setebc!","text":"setebc!(fesp::FESpace, m, eid, comp, val::T) where {T}\n\nSet the EBCs (essential boundary conditions).\n\nm  = manifold dimension of the entity,\neid  = serial number of the entity (term identifier),\ncomp = which  degree of freedom in the term,\nval  = value of type T\n\nFor instance, m = 0 means set  the degree of freedom at the vertex eid.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.dofnum-Union{Tuple{FES}, Tuple{FES,Any,Any,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.dofnum","text":"dofnum(fesp::FES, m, eid)  where {FES<:FESpace}\n\nProvide degree of freedom number for entity eid of manifold dimension m and component comp.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.doftype-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.doftype","text":"doftype(fesp::FESpace{FET, T}) where {FET, T}\n\nProvide the type of the values of the degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofbfnum-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofbfnum","text":"edofbfnum(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of numbers of basis functions associated with each degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofcompnt-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofcompnt","text":"edofcompnt(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of component number associated with each degree of freedom.\n\nWhen the finite element space consists of multiple copies of the scalar finite element, the component is the serial number of the copy.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofmdim-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofmdim","text":"edofmdim(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of manifold dimensions of entities associated with each degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.makeattribute-Tuple{Elfel.FESpaces.FESpace,Any,Any}","page":"Reference","title":"Elfel.FESpaces.makeattribute","text":"makeattribute(fesp::FESpace, name, comp)\n\nAttach attribute to the right shape collection of all incidence relations. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.numberdofs!-Tuple","page":"Reference","title":"Elfel.FESpaces.numberdofs!","text":"numberdofs!(fesp...)\n\nNumber the degrees of freedom of a collection of FE spaces.\n\nThe unknown (free) degrees of freedom in the FE space are numbered consecutively, and then the data degrees of freedom (the known values) are numbered. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.nunknowns-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.nunknowns","text":"nunknowns(fesp::FES)  where {FES<:FESpace}\n\nCompute the total number of unknown degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(fesp::FES)  where {FES<:FESpace}\n\nTotal number of degrees of freedom associated with each finite element.\n\nEssentially a product of the number of the degrees of freedom the scalar finite element and the number of copies of this element in the space.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Fields","page":"Reference","title":"Fields","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FESpaces.FEFields]\nPages   = [\"FEFields.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.FEField","page":"Reference","title":"Elfel.FESpaces.FEFields.FEField","text":"FEField{N, T, IT}\n\nType of a finite element field. Parameterized with\n\nN: number of degrees of freedom per entity, \nT: type of the degree of freedom value, \nIT: type of the index (integer value). This describes the serial numbers of the degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.datadofnums-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.datadofnums","text":"datadofnums(f::FEField)\n\nCollect information about known (data) degree of freedom numbers.\n\nFirst number, last number, and the total number of degrees of freedom are returned as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofnums-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.dofnums","text":"dofnums(fef::FEField, n)\n\nProvide degree of freedom numbers for given entity.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofnumtype-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT}}, Tuple{IT}, Tuple{T}, Tuple{N}} where IT where T where N","page":"Reference","title":"Elfel.FESpaces.FEFields.dofnumtype","text":"dofnumtype(fef::FEField{N, T, IT}) where {N, T, IT}\n\nType of the index (serial number) of the degree of freedom. Integer.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.doftype-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT}}, Tuple{IT}, Tuple{T}, Tuple{N}} where IT where T where N","page":"Reference","title":"Elfel.FESpaces.FEFields.doftype","text":"doftype(fef::FEField{N, T, IT}) where {N, T, IT}\n\nType of a degree of freedom value.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofvals-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.dofvals","text":"dofvals(fef::FEField, n)\n\nProvide degree of freedom values for given entity.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.freedofnums-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.freedofnums","text":"freedofnums(f::FEField)\n\nCollect information about unknown (free) degree of freedom numbers.\n\nFirst number, last number, and the total number of degrees of freedom are returned as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(vec, self::FEField)\n\nGather system vector contributions from the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestdatadofnum-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.highestdatadofnum","text":"highestdatadofnum(f::FEField)\n\nCompute the highest serial number of a datum degree of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestfreedofnum-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.highestfreedofnum","text":"highestfreedofnum(f::FEField)\n\nCompute the highest serial number of a free degree of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofs-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofs","text":"ndofs(fef::FEField)\n\nTotal number of degrees of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofsperterm-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT} where IT where T}, Tuple{N}} where N","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofsperterm","text":"ndofsperterm(fef::FEField{N}) where {N}\n\nNumber of degrees of freedom per term of the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.nterms-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.nterms","text":"nterms(fef::FEField)\n\nNumber of terms in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberdatadofs!","page":"Reference","title":"Elfel.FESpaces.FEFields.numberdatadofs!","text":"numberdatadofs!(f::FEField, firstnum = 1)\n\nNumber the data degrees of freedom in the field. Start from the number supplied on input.\n\nNote: The free degrees of freedom must be numbered first.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberfreedofs!","page":"Reference","title":"Elfel.FESpaces.FEFields.numberfreedofs!","text":"numberfreedofs!(f::FEField, firstnum = 1)\n\nNumber the unknowns in the field, starting from the one supplied on input.\n\nNote: The data degrees of freedom have their numbers zeroed out.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(self::FEField, v)\n\nScatter a system vector into the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.setebc!-Union{Tuple{T}, Tuple{Elfel.FESpaces.FEFields.FEField,Any,Any,T}} where T","page":"Reference","title":"Elfel.FESpaces.FEFields.setebc!","text":"setebc!(self::FEField, tid, comp, val::T) where {T}\n\nSet the value of one particular degree of freedom to a given number.\n\ntid: which term, \ncomp: which component of the term, \nval: value to which the degree of freedom should be set.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Finite-element-iterators","page":"Reference","title":"Finite element iterators","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FEIterators]\nPages   = [\"FEIterators.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FEIterators.FEIterator","page":"Reference","title":"Elfel.FEIterators.FEIterator","text":"FEIterator{FES, IR, G, IT, T, V, IR0, IR1, IR2, IR3, F0, F1, F2, F3}\n\nType of finite element iterator. Parameterized with the types of\n\nFES: finite element space,\nIR: base incidence relation of the mesh, \nG: type of the geometry attribute, \nIT: type of integer indices, such as the  numbers of nodes and degrees of freedom, \nT: type of the degree of freedom value (real double, complex float, ... ), \nV: Val representation of the manifold dimension of the base relation elements, \nIR0, IR1, IR2, IR3: types of incidence relations with which degrees of freedom are associated in the finite element space, for each of the manifolds dimensions 0, 1, 2, 3, \nF0, F1, F2, F3: types of fields with which degrees of freedom are associated in the finite element space, for each of the manifolds dimensions 0, 1, 2, 3.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Base.iterate","page":"Reference","title":"Base.iterate","text":"Base.iterate(it::FEIterator, state = 1)\n\nAdvance the iterator to the next entity.\n\nThe nodes of the finite element are cached, as is a vector of all the degrees of freedom represented on the element.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Base.length-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Base.length","text":"Base.length(it::FEIterator)\n\nNumber of elements represented by this iterator.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofcomps-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofcomps","text":"eldofcomps(it::FEIterator)\n\nRetrieve the vector of the component numbers for each element degree of freedom.\n\nIf multiple copies of the finite element are referenced in the finite element space, each copy is referred to as component.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofentmdims-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofentmdims","text":"eldofentmdims(it::FEIterator)\n\nRetrieve the vector of the entity dimensions for each element degree of freedom.\n\nEach degree of freedom is associated with some entity of the finite element: vertices, edges, faces, and so on. This vector records the dimension of the manifold entity with which each degree of freedom is associated.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofs-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofs","text":"eldofs(it::FEIterator)\n\nRetrieve the vector of the element degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofvals-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofvals","text":"eldofvals(it::FEIterator)\n\nProvide access to vector of element degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.elnodes-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.elnodes","text":"elnodes(it::FEIterator)\n\nRetrieve the vector of the nodes of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.location-Tuple{Elfel.FEIterators.FEIterator,Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FEIterators.location","text":"location(it::FEIterator, qpit::QPIterator)\n\nCalculate the location of the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.jacjac-Tuple{Elfel.FEIterators.FEIterator,Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.jacjac","text":"jacjac(it::FEIterator, qpit::QPIterator)\n\nCompute the Jacobian matrix and the Jacobian determinant.\n\nThe finite element iterator cooperates with the quadrature point iterator here to compute the Jacobian at the current integration point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(it::FEIterator)\n\nRetrieve the number of degrees of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Quadrature-point-iterators","page":"Reference","title":"Quadrature-point iterators","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.QPIterators]\nPages   = [\"QPIterators.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.QPIterators.QPIterator","page":"Reference","title":"Elfel.QPIterators.QPIterator","text":"QPIterator{FES, MDIM}\n\nType of quadrature-point iterator, parameterized by \n\nFES: the type of the finite element space, \nMDIM: the manifold dimension of the finite element.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.QPIterators.QPIterator-Union{Tuple{FES}, Tuple{FES,Any}} where FES","page":"Reference","title":"Elfel.QPIterators.QPIterator","text":"QPIterator(fesp::FES, quadraturesettings) where {FES}\n\nConstruct quadrature-point iterator by associating it with a finite element space and supplying quadrature rule settings.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.iterate-2","page":"Reference","title":"Base.iterate","text":"Base.iterate(it::QPIterator, state = 1)\n\nAdvance a quadrature point iterator.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FElements.bfun-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.bfun","text":"bfun(it::QPIterator)\n\nRetrieve vector of basis function values for the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfungradpar-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.bfungradpar","text":"bfungradpar(it::QPIterator)\n\nRetrieve vector of basis function gradients with respect to the parametric coordinates for the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.QPIterators.bfungrad-Tuple{Elfel.QPIterators.QPIterator,Any}","page":"Reference","title":"Elfel.QPIterators.bfungrad","text":"bfungrad(it::QPIterator, Jac)\n\nRetrieve vector of basis function gradients with respect to spatial coordinates for the current quadrature point.\n\nThe Jacobian matrix maps between vectors in the parametric space and the spatial vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.QPIterators.weight-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.QPIterators.weight","text":"weight(it::QPIterator)\n\nRetrieve weight of the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Assemblers","page":"Reference","title":"Assemblers","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.Assemblers]\nPages   = [\"Assemblers.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.Assemblers.AbstractSysmatAssembler","page":"Reference","title":"Elfel.Assemblers.AbstractSysmatAssembler","text":"AbstractSysmatAssembler\n\nAbstract type of system-matrix assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.AbstractSysvecAssembler","text":"AbstractSysvecAssembler\n\nAbstract type of system vector assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysmatAssemblerSparse","page":"Reference","title":"Elfel.Assemblers.SysmatAssemblerSparse","text":"SysmatAssemblerSparse{T<:Number} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from individual entries.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.SysmatAssemblerSparse","text":"SysmatAssemblerSparse(zero::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\nExample\n\nThis is how a sparse matrix is assembled from two rectangular dense matrices.\n\na = SysmatAssemblerSparse(0.0)                                                        \nstart!(a, 7, 7)  \nm = [0.24406   0.599773    0.833404  0.0420141                                             \n0.786024  0.00206713  0.995379  0.780298                                              \n0.845816  0.198459    0.355149  0.224996]     \ngi = [1 7 5]             \ngj = [5 2 1 4]       \nfor j in 1:size(m, 2), i in 1:size(m, 1)\n    assemble!(a, gi[i], gj[j], m[i, j])       \nend  \nm = [0.146618  0.53471   0.614342    0.737833                                              \n0.479719  0.41354   0.00760941  0.836455                                              \n0.254868  0.476189  0.460794    0.00919633                                            \n0.159064  0.261821  0.317078    0.77646                                               \n0.643538  0.429817  0.59788     0.958909]                                   \ngi =  [2 3 1 7 5]\ngj = [6 7 3 4]   \nfor j in 1:size(m, 2), i in 1:size(m, 1)\n    assemble!(a, gi[i], gj[j], m[i, j])       \nend                               \nA = finish!(a) \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.SysvecAssembler","page":"Reference","title":"Elfel.Assemblers.SysvecAssembler","text":"SysvecAssembler\n\nAssembler for the system vector.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysvecAssembler-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.SysvecAssembler","text":"SysvecAssembler(zero::T=0.0) where {T<:Number}\n\nConstruct blank system vector assembler. The vector entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Any,Any,T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, r, c, v::T) where {T<:Number}\n\nAssemble a single entry of a rectangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Any,T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysvecAssembler{T}, i, val::T) where {T<:Number}\n\nAssemble a single value into the row i.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Any}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysvecAssembler{T}, lva) where {T<:Number}\n\nAssemble local vector assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{IT}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T}}} where T<:Number where IT<:Integer","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, lma::LocalMatrixAssembler{IT, T}) where {IT<:Integer, T<:Number}\n\nAssemble the row numbers, column numbers, and values from a local assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{IT}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},LinearAlgebra.Transpose{T,Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T}}}} where T<:Number where IT<:Integer","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, lma::Transpose{T,LocalMatrixAssembler{IT,T}}) where {IT<:Integer, T<:Number}\n\nAssemble the row numbers, column numbers, and values from a local assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Any,T}} where T<:Number where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SV, i, val::T) where {SV<:AbstractSysvecAssembler, T<:Number}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Tuple{Elfel.Assemblers.SysmatAssemblerSparse}","page":"Reference","title":"Elfel.Assemblers.finish!","text":"finish!(self::SysmatAssemblerSparse)\n\nMake a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Tuple{Elfel.Assemblers.SysvecAssembler}","page":"Reference","title":"Elfel.Assemblers.finish!","text":"finish!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Union{Tuple{SV}, Tuple{SV}} where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.finish!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Any,Any}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SysmatAssemblerSparse{T}, nrow, ncol) where {T<:Number}\n\nStart the assembly of a global matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Int64}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SysvecAssembler{T},  nrow::Int64) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nnrow= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Any}} where T<:Number where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SV,  nrow) where {SV<:AbstractSysvecAssembler, T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nnrow= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Local-Assemblers","page":"Reference","title":"Local Assemblers","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.LocalAssemblers]\nPages   = [\"LocalAssemblers.jl\"]","category":"page"},{"location":"man/reference.html#Base.IndexStyle-Tuple{Type{#s15} where #s15<:Elfel.LocalAssemblers.LocalMatrixAssembler}","page":"Reference","title":"Base.IndexStyle","text":"Base.IndexStyle(::Type{<:LocalMatrixAssembler})\n\nThe data storage is assumed to be consumed best by one-dimensional traversal through the columns in a linear fashion.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.IndexStyle-Tuple{Type{#s15} where #s15<:Elfel.LocalAssemblers.LocalVectorAssembler}","page":"Reference","title":"Base.IndexStyle","text":"Base.IndexStyle(::Type{<:LocalVectorAssembler})\n\nOnly linear access is provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Elfel.LocalAssemblers.LocalMatrixAssembler","text":"LocalMatrixAssembler{IT<:Integer, T<:Number} <: AbstractArray{T, 2}\n\nType of \"local\" matrix assembler.\n\nLocal is to be understood in the sense of in the context of a single finite element. So a local matrix is an elementwise matrix which is computed entry by entry. Then it can be assembled into the global matrix in one shot.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalMatrixAssembler-Union{Tuple{T}, Tuple{IT}, Tuple{IT,IT,T}} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.LocalMatrixAssembler","text":"LocalMatrixAssembler(nrow::IT, ncol::IT, z::T) where {IT, T}\n\nCreate a local matrix assembler, given the number of rows and columns, and the value to which the matrix should be initialized.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Elfel.LocalAssemblers.LocalVectorAssembler","text":"LocalVectorAssembler{IT<:Integer, T<:Number} <: AbstractArray{T, 1}\n\nType of \"local\" vector assembler.\n\nLocal is to be understood in the sense of in the context of a single finite element. So a local vector is an elementwise vector which is computed entry by entry. Then it can be assembled into the global vector in one shot.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalVectorAssembler-Union{Tuple{T}, Tuple{IT}, Tuple{IT,T}} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.LocalVectorAssembler","text":"LocalVectorAssembler(nrow::IT, z::T) where {IT, T}\n\nCreate a local vector assembler, given the number of entries, and the value to which the vector should be initialized.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.getindex-Union{Tuple{A}, Tuple{A,Int64,Int64}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.getindex","text":"Base.getindex(a::A, i::Int, j::Int)\n\nOnly access to a single entry of the matrix is  provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.getindex-Union{Tuple{A}, Tuple{A,Int64}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.getindex","text":"Base.getindex(a::A, i::Int) where {A<:LocalVectorAssembler}\n\nAccess is provided to a single entry of the vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.setindex!-Union{Tuple{A}, Tuple{A,Any,Int64,Int64}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(a::A, v, i::Int, j::Int) where {A<:LocalMatrixAssembler}\n\nOnly access to a single entry of the matrix is  provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.setindex!-Union{Tuple{A}, Tuple{A,Any,Int64}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(a::A, v, i::Int) where {A<:LocalVectorAssembler}\n\nAccess is provided to a single entry of the vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.size-Union{Tuple{A}, Tuple{A}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.size","text":"Base.size(a::A) where {A<:LocalMatrixAssembler}\n\nThe size is the tuple of number of rows and number of columns.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.size-Union{Tuple{A}, Tuple{A}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.size","text":"Base.size(a::A) where {A<:LocalVectorAssembler}\n\nThe size is the number of rows (entries).\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.init!-Union{Tuple{L}, Tuple{T}, Tuple{IT}, Tuple{L,Any,Any}} where L<:Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.init!","text":"init!(a::L, rdofs, cdofs) where {L<:LocalMatrixAssembler{IT, T}} where {IT, T}\n\nInitialize the  local assembler with the global degrees of freedom in the rows and columns.\n\nThe two arrays, rdofs, cdofs, define the global degree of freedom numbers for the element. The data matrix is zeroed out. \n\nThis function needs to be called for each new finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.init!-Union{Tuple{L}, Tuple{T}, Tuple{IT}, Tuple{L,Any}} where L<:Elfel.LocalAssemblers.LocalVectorAssembler{IT,T} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.init!","text":"init!(a::L, rdofs) where {L<:LocalVectorAssembler{IT, T}} where {IT, T}\n\nInitialize the  local assembler with the global degrees of freedom in the rows.\n\nThe array rdofs defines the global degree of freedom numbers for the element. The data vector is zeroed out. \n\nThis function needs to be called for each new finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Table of contents","category":"page"},{"location":"concepts/concepts.html#Design-and-operation-concepts","page":"Concepts","title":"Design and operation concepts","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Needs to be written.","category":"page"},{"location":"concepts/concepts.html#Why-a-library-of-components","page":"Concepts","title":"Why a library of components","text":"","category":"section"},{"location":"concepts/concepts.html#Basic-types","page":"Concepts","title":"Basic types","text":"","category":"section"},{"location":"concepts/concepts.html#Meshes","page":"Concepts","title":"Meshes","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#How-to-Guide","page":"How to guide","title":"How to Guide","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Needs to be written.","category":"page"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Table of contents","category":"page"},{"location":"tutorials/tutorials.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Heat conduction: Poisson equation. Manufactured solution.\nColliding flow Stokes equation. Manufactured solution. Hood-Taylor mixed velocity-pressure triangles.","category":"page"},{"location":"index.html#Elfel-Documentation","page":"Home","title":"Elfel Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Elfel provides support for the development of Finite Element Method applications, especially in the area of continuum mechanics. Mixed methods with cooperating finite element spaces are supported. High performance is one of the focus points.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this package is predicated on the notion that it will provide simple building blocks  to  those who wish to explore the internals of finite element methods.  Hence the focus is on low-level building blocks rather than on prepackaged, high-level, functionality.","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tutorials showing application of the library to some common PDE problems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/tutorials.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#How-to-guide","page":"Home","title":"How to guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The recipes.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Reference-manual","page":"Home","title":"Reference manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and functions.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/reference.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The concepts and ideas are described.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"concepts/concepts.md\",\n]\nDepth = 1","category":"page"}]
}
