var documenterSearchIndex = {"docs":
[{"location":"tutorials/tut_poisson_q4.html#Solve-the-heat-conduction-equation","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"","category":"section"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Synopsis: Compute the solution of the Poisson equation of heat conduction with a nonzero heat source. Quadrilateral four-node elements are used.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The problem is linear heat conduction equation posed on a bi-unit square, solved with Dirichlet boundary conditions around the circumference. Uniform nonzero heat generation rate is present. The exact solution is in this way manufactured and hence known. That gives us an opportunity to calculate the true error.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The complete code is in the file tut_poisson_q4.jl.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"module tut_poisson_q4","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"We'll need some functionality from linear algebra, and the mesh libraries. Finally we will need the Elfel functionality.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"using LinearAlgebra\nusing MeshCore.Exports\nusing MeshSteward.Exports\nusing Elfel.Exports","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is the top level function.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function run()","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Input parameters:","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    A = 1.0 # length of the side of the square\n    kappa =  1.0; # thermal conductivity of the material\n    Q = -6.0; # internal heat generation rate\n    tempf(x, y) =(1.0 + x^2 + 2.0 * y^2); # the exact distribution of temperature\n    N = 1000; # number of element edges along the sides of the square domain","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Generate the computational mesh.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    mesh = genmesh(A, N)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Create the finite element space to represent the temperature solution. The degrees of freedom are real numbers (Float64), the quadrilaterals are defined by the mesh, and each of the elements has the continuity H ^1, i. e. both the function values and the derivatives are square integrable.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    Uh = FESpace(Float64, mesh, FEH1_Q4())","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Apply the essential boundary conditions at the circumference of the square domain. We find the boundary incidence relation (boundary(mesh)), and then the list of all vertices connected by the boundary cells. The function tempf defines the analytical temperature variation, and hence for each of the vertices i on the boundary (they are of manifold dimension  0), we set the component of the field (1) to the exact value of the temperature at that location.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    vl = connectedv(boundary(mesh));\n    locs = geometry(mesh)\n    for i in vl\n        setebc!(Uh, 0, i, 1, tempf(locs[i]...))\n    end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Number the degrees of freedom, both the unknowns and the data (prescribed) degrees of freedom.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    numberdofs!(Uh)\n    @show ndofs(Uh), nunknowns(Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Assemble the conductivity matrix and the vector of the heat loads. Refer to the definition of this function below.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    K, F = assembleKF(Uh, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is a vector to hold all degrees of freedom in the system.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    T = fill(0.0, ndofs(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Here we collect the data degrees of freedom (the known values).","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    gathersysvec!(T, Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The system of linear algebraic equations is solved.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    solve!(T, K, F, nunknowns(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The values of all the degrees of freedom can now be introduced into the finite element space.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    scattersysvec!(Uh, T)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Here we associate the values of the finite element space with the entities of the mesh as an attribute.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    makeattribute(Uh, \"T\", 1)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The correctness of the solution is checked by comparing the values at the vertices.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    checkcorrectness(Uh, tempf)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The attribute can now be written out for visualization into a VTK file.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    vtkwrite(\"q4-T\", baseincrel(mesh), [(name = \"T\",)])\n\n    true # return success\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The domain is a square, meshed with quadrilateral elements. The function Q4block creates an incidence relation that defines the quadrilateral element shapes by the vertices connected into the shapes. This incidence relation is then attached to the mesh and the mesh is returned.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function genmesh(A, N)\n    conn = Q4block(A, A, N, N)\n    return attach!(Mesh(), conn)\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The assembleKF function constructs the left-hand side coefficient matrix, conductivity matrix, as a sparse matrix, and a vector of the heat loads due to the internal heat generation rate Q.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The boundary value problem is expressed in this weak form","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V\n            -int_V  vartheta Q  mathrmd V\n             = 0","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"where the test function vanishes on the boundary where the temperature is prescribed, vartheta(x) =0  for  x inS_1 Substituting vartheta = N_j and T = sum_i N_i T_i we obtain the linear algebraic equations","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"sum_i T_i int_V mathrmgradN_j  kappa (mathrmgradN_i)^T mathrmd V\n -int_V  N_j Q  mathrmd V  = 0  quad forall j","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The volume element is mathrmd V, which in our case becomes 10timesmathrmd S, since the thickness of the two dimensional domain is assumed to be 1.0.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function assembleKF(Uh, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"At the top of the assembleKF we look at the function integrate! to evaluate the weak-form integrals. The key to making this calculation efficient is type stability. All the arguments coming in must have concrete types. This is why the integrate! function is an inner function: the function barrier allows for all arguments to be resolved to concrete types.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    function integrate!(am, av, elit, qpit, kappa, Q)\n        nedof = ndofsperel(elit)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The local assemblers are just like matrices or vectors","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"        ke = LocalMatrixAssembler(nedof, nedof, 0.0)\n        fe = LocalVectorAssembler(nedof, 0.0)\n        for el in elit # Loop over all elements\n            init!(ke, eldofs(el), eldofs(el)) # zero out elementwise matrix\n            init!(fe, eldofs(el)) # and vector\n            for qp in qpit # Now loop over the quadrature points\n                Jac, J = jacjac(el, qp) # Calculate the Jacobian matrix, Jacobian\n                gradN = bfungrad(qp, Jac) # Evaluate the spatial gradients\n                JxW = J * weight(qp) # elementary volume\n                N = bfun(qp) # Basis function values at the quadrature point","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This double loop evaluates the elementwise conductivity matrix and the heat load vector precisely as the formula of the weak form  dictates; see above.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"                for i in 1:nedof\n                    for j in 1:nedof\n                        ke[j, i] += dot(gradN[j], gradN[i]) * (kappa * JxW)\n                    end\n                    fe[j] += N[j] * Q * JxW\n                end\n            end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Assemble the calculated contributions from this element","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"            assemble!(am, ke)\n            assemble!(av, fe)\n        end\n        return am, av # Return the updated assemblers\n    end","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"In the assembleKF function we first we create the element iterator. We can go through all the elements that define the domain of integration using this iterator. Each time a new element is accessed, some data are precomputed such as the element degrees of freedom.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    elit = FEIterator(Uh)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This is the quadrature point iterator. We know that the elements are quadrilateral, which makes the Gauss integration rule the obvious choice. We also select order 2 for accuracy. Quadrature-point iterators provide access to basis function values and gradients, the Jacobian matrix and the Jacobian determinant, the location of the quadrature point and so on.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    qpit = QPIterator(Uh, (kind = :Gauss, order = 2))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Next we create assemblers, one for the sparse system matrix and one for the system vector.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    am = start!(SysmatAssemblerSparse(0.0), ndofs(Uh), ndofs(Uh))\n    av = start!(SysvecAssembler(0.0), ndofs(Uh))","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"Now we call the integration function. The assemblers are modified inside this function...","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    @time integrate!(am, av, elit, qpit, kappa, Q)","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"...so that when the integration is done, we can materialize the sparse matrix and the vector and return them.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"    return finish!(am), finish!(av)\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The linear algebraic system is solved by partitioning. The vector T is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the conductivity matrix and the vector T are the heat loads due to nonzero essential boundary conditions. To this we add the vector of heat loads due to the internal heat generation rate. The submatrix of the heat conduction matrix corresponding to the free degrees of freedom (unknowns), K[1:nu, 1:nu] is then used to solve for the unknowns T [1:nu].","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function solve!(T, K, F, nu)\n    @time KT = K * T\n    @time T[1:nu] = K[1:nu, 1:nu] \\ (F[1:nu] - KT[1:nu])\nend","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The correctness can be checked in various ways. Here we calculate the mean deviation of the calculated temperatures at the nodes relative to the exact values of the temperature.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"function checkcorrectness(Uh, tempf)\n    geom = geometry(Uh.mesh)\n    ir = baseincrel(Uh.mesh)\n    T = attribute(ir.right, \"T\")\n    std = 0.0\n    for i in 1:length(T)\n        std += abs(T[i][1] - tempf(geom[i]...))\n    end\n    @show (std / length(T)) <= 1.0e-9\nend\n\nend # module","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"The module can now be used.","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"using .tut_poisson_q4\ntut_poisson_q4.run()","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"","category":"page"},{"location":"tutorials/tut_poisson_q4.html","page":"Solve the heat conduction equation","title":"Solve the heat conduction equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/reference.html#Reference-manual","page":"Reference","title":"Reference manual","text":"","category":"section"},{"location":"man/reference.html#Reference-shapes","page":"Reference","title":"Reference shapes","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.RefShapes]\nPages   = [\"RefShapes.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.RefShapes.AbstractRefShape","page":"Reference","title":"Elfel.RefShapes.AbstractRefShape","text":"AbstractRefShape{MANIFDIM}\n\nAbstract type of a reference shape.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.IntegRule","page":"Reference","title":"Elfel.RefShapes.IntegRule","text":"IntegRule\n\nType for integration rule.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeCube","page":"Reference","title":"Elfel.RefShapes.RefShapeCube","text":"RefShapeCube <: AbstractRefShape{3}\n\nType of a reference shape for a 3-dimensional manifold (solid) bounded by six quadrilaterals.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeInterval","page":"Reference","title":"Elfel.RefShapes.RefShapeInterval","text":"RefShapeInterval <: AbstractRefShape{1}\n\nType of a reference shape for a 1-dimensional manifold (curve).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapePoint","page":"Reference","title":"Elfel.RefShapes.RefShapePoint","text":"RefShapePoint <: AbstractRefShape{0}\n\nType of a reference shape for a zero-dimensional manifold (point).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeSquare","page":"Reference","title":"Elfel.RefShapes.RefShapeSquare","text":"RefShapeSquare <: AbstractRefShape{2}\n\nType of a logically rectangular reference shape for a 2-dimensional manifold  (surface).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeTetrahedron","page":"Reference","title":"Elfel.RefShapes.RefShapeTetrahedron","text":"RefShapeTetrahedron <: AbstractRefShape{3}\n\nType of a reference shape for a 3-dimensional manifold (solid) bounded by 4 triangles.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.RefShapeTriangle","page":"Reference","title":"Elfel.RefShapes.RefShapeTriangle","text":"RefShapeTriangle <: AbstractRefShape{2}\n\nType of a logically triangular reference shape for a 2-dimensional manifold  (surface).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.RefShapes.manifdim-Union{Tuple{Type{T}}, Tuple{T}, Tuple{MANIFDIM}} where T<:Elfel.RefShapes.AbstractRefShape{MANIFDIM} where MANIFDIM","page":"Reference","title":"Elfel.RefShapes.manifdim","text":"manifdim(rs)\n\nGet the manifold dimension of the reference shape.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.RefShapes.manifdimv-Union{Tuple{Type{T}}, Tuple{T}, Tuple{MANIFDIM}} where T<:Elfel.RefShapes.AbstractRefShape{MANIFDIM} where MANIFDIM","page":"Reference","title":"Elfel.RefShapes.manifdimv","text":"manifdimv(::Type{T}) where {T<:AbstractRefShape{MANIFDIM}} where {MANIFDIM}\n\nGet the manifold dimension of the reference shape as Val. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.RefShapes.quadrature","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeTetrahedron}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of a tetrahedron.\n\nThe default is a one-point tetrahedron rule; other rules may be chosen based on the number of points set with the keyword npts.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-2","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeSquare}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of a square.\n\nThe default is Gauss integration rule, where the order is set with the keyword order.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-3","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeTriangle}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of an triangle.\n\nThe default is a triangle rule, distinguished by the number of points set with the keyword npts.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.RefShapes.quadrature-4","page":"Reference","title":"Elfel.RefShapes.quadrature","text":"quadrature(::Type{RefShapeInterval}, quadraturesettings = (kind = :default,))\n\nCreate a quadrature rule for the reference shape of an interval.\n\nThe default is Gauss integration rule, where the order is set with the keyword order.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elements","page":"Reference","title":"Elements","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FElements]\nPages   = [\"FElements.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FElements.FE","page":"Reference","title":"Elfel.FElements.FE","text":"FE{RS, SD}\n\nAbstract type of finite element, parameterized by\n\nRS: type of reference shape of the element (triangle, square, ...), and\nSD: shape descriptor; refer to the package MeshCore.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FElements.FEData","page":"Reference","title":"Elfel.FElements.FEData","text":"FEData{SD}\n\nType of a finite element data. \n\nParameterized by\n\nSD = shape descriptor; refer to the package MeshCore.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FElements.FEH1_L2-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_L2","text":"FEH1_L2()\n\nConstruct an H1 finite element of the type L2.\n\nL2 is two-node linear segment element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_Q4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_Q4","text":"FEH1_Q4()\n\nConstruct an H1 finite element of the type Q4.\n\nQ4 is 4-node linear quadrilateral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T3-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T3","text":"FEH1_T3()\n\nConstruct an H1 finite element of the type T3.\n\nT3 is 3-node linear triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T3_BUBBLE-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T3_BUBBLE","text":"FEH1_T3_BUBBLE()\n\nConstruct an H1 finite element of the type T3 with a cubic bubble.\n\nT3 is 3-node linear triangle element with a cubic bubble. It has the usual nodal basis functions associated with the vertices, and cubic bubble associated with the element itself.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T4","text":"FEH1_T4()\n\nConstruct an H1 finite element of the type T4.\n\nT4 is 4-node linear tetrahedral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEH1_T6-Tuple{}","page":"Reference","title":"Elfel.FElements.FEH1_T6","text":"FEH1_T6()\n\nConstruct an H1 finite element of the type T6.\n\nT6 is 6-node quadratic triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_Q4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_Q4","text":"FEL2_Q4()\n\nConstruct an L2 finite element of the type Q4.\n\nQ4 is 4-node linear quadrilateral element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_T3-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_T3","text":"FEL2_T3()\n\nConstruct an L2 finite element of the type T3.\n\nT3 is 3-node linear triangle element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.FEL2_T4-Tuple{}","page":"Reference","title":"Elfel.FElements.FEL2_T4","text":"FEL2_T4()\n\nConstruct an L2 finite element of the type T4.\n\nT4 is tetrahedral element with only internal degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{0},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{0}, J::T) where {T}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix, which isn't really defined well for a 0-manifold.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{1},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{1}, J::T) where {T}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{2},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(::Val{2}, J::T) where {T}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.Jacobian-Union{Tuple{T}, Tuple{Val{3},T}} where T","page":"Reference","title":"Elfel.FElements.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet3Manifold}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfun-Union{Tuple{FESUBT}, Tuple{SD}, Tuple{RS}, Tuple{FESUBT,Any}} where FESUBT<:Elfel.FElements.FE{RS,SD} where SD where RS","page":"Reference","title":"Elfel.FElements.bfun","text":"bfun(self::FESUBT,  param_coords)  where {FESUBT<:FE{RS, SD}}\n\nEvaluate the basis functions for all degrees of freedom of the scalar finite element at the parametric coordinates. Return a vector of the values.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfungradpar-Union{Tuple{FESUBT}, Tuple{SD}, Tuple{RS}, Tuple{FESUBT,Any}} where FESUBT<:Elfel.FElements.FE{RS,SD} where SD where RS","page":"Reference","title":"Elfel.FElements.bfungradpar","text":"bfungradpar(self::FESUBT,  param_coords)  where {FESUBT<:FE{RS, SD}}\n\nEvaluate the gradients of the basis functions for all degrees of freedom of the scalar finite element with respect to the parametric coordinates, at the parametric coordinates given. Return a vector of the gradients.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.jacjac-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any,Any,Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.jacjac","text":"jacjac(fe::FE{RS, SD}, locs, nodes, gradNpar) where {RS, SD}\n\nCompute the Jacobian matrix and the Jacobian determinant.\n\nThis is the generic version suitable for isoparametric elements.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofperfeat-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.ndofperfeat","text":"feathasdof(fe::FE{RS, SD}, m) where {RS, SD}\n\nHow many degrees of freedom are attached to a the feature of manifold dimension m?\n\nNote that 0 <= m <= 3.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(fe::FE{RS, SD}) where {RS, SD}\n\nProvide the number of degrees of freedom per element.\n\nEnumerate all features of all manifold dimensions, and for each feature multiply by the number of degrees of freedom per feature. The assumption is that this is a scalar finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.nfeatofdim-Union{Tuple{SD}, Tuple{RS}, Tuple{Elfel.FElements.FE{RS,SD},Any}} where SD where RS","page":"Reference","title":"Elfel.FElements.nfeatofdim","text":"nfeatofdim(fe::FE{RS, SD}, m) where {RS, SD}\n\nNumber of features of manifold dimension m. Note that 0 <= m <= 3.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.refshape-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.refshape","text":"refshape(fe::FE{RS, SD}) where {RS, SD}\n\nReference shape.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.shapedesc-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"Elfel.FElements.shapedesc","text":"shapedesc(fe::FE{RS, SD}) where {RS, SD}\n\nTopological shape description.\n\nRefer to the MeshCore library.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#MeshCore.manifdim-Union{Tuple{Elfel.FElements.FE{RS,SD}}, Tuple{SD}, Tuple{RS}} where SD where RS","page":"Reference","title":"MeshCore.manifdim","text":"manifdim(fe::FE{RS, SD}) where {RS, SD}\n\nGet the manifold dimension of the finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Spaces","page":"Reference","title":"Spaces","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FESpaces]\nPages   = [\"FESpaces.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FESpace","text":"FESpace{FET, T}\n\nType of a finite element space, parameterized with\n\nFET: type of finite element, it is a scalar finite element, \nT: type of degree of freedom value (double, complex, ...).\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,AbstractArray{T,1} where T}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(v, fesp)\n\nGather values for the whole system vector from all FE spaces contributing to it.\n\nfesp is either a vector or a tuple of FE spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,Elfel.FESpaces.FESpace}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(v, fesp::FESpace)\n\nGather values for the whole system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestdatadofnum-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.highestdatadofnum","text":"highestfreedofnum(fesp::FES)  where {FES<:FESpace}\n\nCompute the highest number of data (known) degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestfreedofnum-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.highestfreedofnum","text":"highestfreedofnum(fesp::FES)  where {FES<:FESpace}\n\nCompute the highest number of free (unknown) degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofs-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofs","text":"ndofs(fesp::FES)  where {FES<:FESpace}\n\nCompute the total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberdatadofs!-Union{Tuple{FES}, Tuple{FES}, Tuple{FES,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.numberdatadofs!","text":"numberdatadofs!(fesp::FES, firstnum = 1)  where {FES<:FESpace}\n\nNumber the data (known) degrees of freedom.\n\nThe known degrees of freedom in the FE space are numbered consecutively. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberfreedofs!-Union{Tuple{FES}, Tuple{FES}, Tuple{FES,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.FEFields.numberfreedofs!","text":"numberfreedofs!(fesp::FES, firstnum = 1)  where {FES<:FESpace}\n\nNumber the free degrees of freedom.\n\nThe unknown degrees of freedom in the FE space are numbered consecutively. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{AbstractArray{T,1} where T,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(fesp, v)\n\nScatter values for the whole system vector to all FE spaces contributing to it.\n\nfesp is either a vector or a tuple of FE spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{Elfel.FESpaces.FESpace,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(fesp::FESpace, v)\n\nScatter values from the system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.setebc!-Union{Tuple{T}, Tuple{Elfel.FESpaces.FESpace,Any,Any,Any,T}} where T","page":"Reference","title":"Elfel.FESpaces.FEFields.setebc!","text":"setebc!(fesp::FESpace, m, eid, comp, val::T) where {T}\n\nSet the EBCs (essential boundary conditions).\n\nm  = manifold dimension of the entity,\neid  = serial number of the entity (term identifier),\ncomp = which  degree of freedom in the term,\nval  = value of type T\n\nFor instance, m = 0 means set  the degree of freedom at the vertex eid.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.dofnum-Union{Tuple{FES}, Tuple{FES,Any,Any,Any}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.dofnum","text":"dofnum(fesp::FES, m, eid)  where {FES<:FESpace}\n\nProvide degree of freedom number for entity eid of manifold dimension m and component comp.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.doftype-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.doftype","text":"doftype(fesp::FESpace{FET, T}) where {FET, T}\n\nProvide the type of the values of the degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofbfnum-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofbfnum","text":"edofbfnum(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of numbers of basis functions associated with each degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofcompnt-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofcompnt","text":"edofcompnt(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of component number associated with each degree of freedom.\n\nWhen the finite element space consists of multiple copies of the scalar finite element, the component is the serial number of the copy.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.edofmdim-Union{Tuple{Elfel.FESpaces.FESpace{FET,T}}, Tuple{T}, Tuple{FET}} where T where FET","page":"Reference","title":"Elfel.FESpaces.edofmdim","text":"edofmdim(fesp::FESpace{FET, T}) where {FET, T}\n\nAccess vector of manifold dimensions of entities associated with each degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.makeattribute-Tuple{Elfel.FESpaces.FESpace,Any,Any}","page":"Reference","title":"Elfel.FESpaces.makeattribute","text":"makeattribute(fesp::FESpace, name, comp)\n\nAttach attribute to the right shape collection of all incidence relations. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.numberdofs!-Tuple","page":"Reference","title":"Elfel.FESpaces.numberdofs!","text":"numberdofs!(fesp...)\n\nNumber the degrees of freedom of a collection of FE spaces.\n\nThe unknown (free) degrees of freedom in the FE space are numbered consecutively, and then the data degrees of freedom (the known values) are numbered. \n\nNo effort is made to optimize the numbering in any way. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.nunknowns-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FESpaces.nunknowns","text":"nunknowns(fesp::FES)  where {FES<:FESpace}\n\nCompute the total number of unknown degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Union{Tuple{FES}, Tuple{FES}} where FES<:Elfel.FESpaces.FESpace","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(fesp::FES)  where {FES<:FESpace}\n\nTotal number of degrees of freedom associated with each finite element.\n\nEssentially a product of the number of the degrees of freedom the scalar finite element and the number of copies of this element in the space.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Fields","page":"Reference","title":"Fields","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FESpaces.FEFields]\nPages   = [\"FEFields.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.FEField","page":"Reference","title":"Elfel.FESpaces.FEFields.FEField","text":"FEField{N, T, IT}\n\nType of a finite element field. Parameterized with\n\nN: number of degrees of freedom per entity, \nT: type of the degree of freedom value, \nIT: type of the index (integer value). This describes the serial numbers of the degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.datadofnums-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.datadofnums","text":"datadofnums(f::FEField)\n\nCollect information about known (data) degree of freedom numbers.\n\nFirst number, last number, and the total number of degrees of freedom are returned as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofnums-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.dofnums","text":"dofnums(fef::FEField, n)\n\nProvide degree of freedom numbers for given entity.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofnumtype-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT}}, Tuple{IT}, Tuple{T}, Tuple{N}} where IT where T where N","page":"Reference","title":"Elfel.FESpaces.FEFields.dofnumtype","text":"dofnumtype(fef::FEField{N, T, IT}) where {N, T, IT}\n\nType of the index (serial number) of the degree of freedom. Integer.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.doftype-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT}}, Tuple{IT}, Tuple{T}, Tuple{N}} where IT where T where N","page":"Reference","title":"Elfel.FESpaces.FEFields.doftype","text":"doftype(fef::FEField{N, T, IT}) where {N, T, IT}\n\nType of a degree of freedom value.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.dofvals-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.dofvals","text":"dofvals(fef::FEField, n)\n\nProvide degree of freedom values for given entity.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.freedofnums-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.freedofnums","text":"freedofnums(f::FEField)\n\nCollect information about unknown (free) degree of freedom numbers.\n\nFirst number, last number, and the total number of degrees of freedom are returned as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.gathersysvec!-Tuple{Any,Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.gathersysvec!","text":"gathersysvec!(vec, self::FEField)\n\nGather system vector contributions from the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestdatadofnum-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.highestdatadofnum","text":"highestdatadofnum(f::FEField)\n\nCompute the highest serial number of a datum degree of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.highestfreedofnum-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.highestfreedofnum","text":"highestfreedofnum(f::FEField)\n\nCompute the highest serial number of a free degree of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofs-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofs","text":"ndofs(fef::FEField)\n\nTotal number of degrees of freedom in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.ndofsperterm-Union{Tuple{Elfel.FESpaces.FEFields.FEField{N,T,IT} where IT where T}, Tuple{N}} where N","page":"Reference","title":"Elfel.FESpaces.FEFields.ndofsperterm","text":"ndofsperterm(fef::FEField{N}) where {N}\n\nNumber of degrees of freedom per term of the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.nterms-Tuple{Elfel.FESpaces.FEFields.FEField}","page":"Reference","title":"Elfel.FESpaces.FEFields.nterms","text":"nterms(fef::FEField)\n\nNumber of terms in the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberdatadofs!","page":"Reference","title":"Elfel.FESpaces.FEFields.numberdatadofs!","text":"numberdatadofs!(f::FEField, firstnum = 1)\n\nNumber the data degrees of freedom in the field. Start from the number supplied on input.\n\nNote: The free degrees of freedom must be numbered first.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.numberfreedofs!","page":"Reference","title":"Elfel.FESpaces.FEFields.numberfreedofs!","text":"numberfreedofs!(f::FEField, firstnum = 1)\n\nNumber the unknowns in the field, starting from the one supplied on input.\n\nNote: The data degrees of freedom have their numbers zeroed out.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.scattersysvec!-Tuple{Elfel.FESpaces.FEFields.FEField,Any}","page":"Reference","title":"Elfel.FESpaces.FEFields.scattersysvec!","text":"scattersysvec!(self::FEField, v)\n\nScatter a system vector into the field.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FESpaces.FEFields.setebc!-Union{Tuple{T}, Tuple{Elfel.FESpaces.FEFields.FEField,Any,Any,T}} where T","page":"Reference","title":"Elfel.FESpaces.FEFields.setebc!","text":"setebc!(self::FEField, tid, comp, val::T) where {T}\n\nSet the value of one particular degree of freedom to a given number.\n\ntid: which term, \ncomp: which component of the term, \nval: value to which the degree of freedom should be set.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Finite-element-iterators","page":"Reference","title":"Finite element iterators","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.FEIterators]\nPages   = [\"FEIterators.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.FEIterators.FEIterator","page":"Reference","title":"Elfel.FEIterators.FEIterator","text":"FEIterator{FES, IR, G, IT, T, V, IR0, IR1, IR2, IR3, F0, F1, F2, F3}\n\nType of finite element iterator. Parameterized with the types of\n\nFES: finite element space,\nIR: base incidence relation of the mesh, \nG: type of the geometry attribute, \nIT: type of integer indices, such as the  numbers of nodes and degrees of freedom, \nT: type of the degree of freedom value (real double, complex float, ... ), \nV: Val representation of the manifold dimension of the base relation elements, \nIR0, IR1, IR2, IR3: types of incidence relations with which degrees of freedom are associated in the finite element space, for each of the manifolds dimensions 0, 1, 2, 3, \nF0, F1, F2, F3: types of fields with which degrees of freedom are associated in the finite element space, for each of the manifolds dimensions 0, 1, 2, 3.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Base.iterate","page":"Reference","title":"Base.iterate","text":"Base.iterate(it::FEIterator, state = 1)\n\nAdvance the iterator to the next entity.\n\nThe nodes of the finite element are cached, as is a vector of all the degrees of freedom represented on the element.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Base.length-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Base.length","text":"Base.length(it::FEIterator)\n\nNumber of elements represented by this iterator.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofcomps-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofcomps","text":"eldofcomps(it::FEIterator)\n\nRetrieve the vector of the component numbers for each element degree of freedom.\n\nIf multiple copies of the finite element are referenced in the finite element space, each copy is referred to as component.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofentmdims-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofentmdims","text":"eldofentmdims(it::FEIterator)\n\nRetrieve the vector of the entity dimensions for each element degree of freedom.\n\nEach degree of freedom is associated with some entity of the finite element: vertices, edges, faces, and so on. This vector records the dimension of the manifold entity with which each degree of freedom is associated.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofs-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofs","text":"eldofs(it::FEIterator)\n\nRetrieve the vector of the element degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.eldofvals-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.eldofvals","text":"eldofvals(it::FEIterator)\n\nProvide access to vector of element degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.elnodes-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FEIterators.elnodes","text":"elnodes(it::FEIterator)\n\nRetrieve the vector of the nodes of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FEIterators.location-Tuple{Elfel.FEIterators.FEIterator,Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FEIterators.location","text":"location(it::FEIterator, qpit::QPIterator)\n\nCalculate the location of the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.jacjac-Tuple{Elfel.FEIterators.FEIterator,Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.jacjac","text":"jacjac(it::FEIterator, qpit::QPIterator)\n\nCompute the Jacobian matrix and the Jacobian determinant.\n\nThe finite element iterator cooperates with the quadrature point iterator here to compute the Jacobian at the current integration point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.ndofsperel-Tuple{Elfel.FEIterators.FEIterator}","page":"Reference","title":"Elfel.FElements.ndofsperel","text":"ndofsperel(it::FEIterator)\n\nRetrieve the number of degrees of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Quadrature-point-iterators","page":"Reference","title":"Quadrature-point iterators","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.QPIterators]\nPages   = [\"QPIterators.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.QPIterators.QPIterator","page":"Reference","title":"Elfel.QPIterators.QPIterator","text":"QPIterator{FES, MDIM}\n\nType of quadrature-point iterator, parameterized by \n\nFES: the type of the finite element space, \nMDIM: the manifold dimension of the finite element.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.QPIterators.QPIterator-Union{Tuple{FES}, Tuple{FES,Any}} where FES","page":"Reference","title":"Elfel.QPIterators.QPIterator","text":"QPIterator(fesp::FES, quadraturesettings) where {FES}\n\nConstruct quadrature-point iterator by associating it with a finite element space and supplying quadrature rule settings.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.iterate-2","page":"Reference","title":"Base.iterate","text":"Base.iterate(it::QPIterator, state = 1)\n\nAdvance a quadrature point iterator.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Elfel.FElements.bfun-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.bfun","text":"bfun(it::QPIterator)\n\nRetrieve vector of basis function values for the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.FElements.bfungradpar-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.FElements.bfungradpar","text":"bfungradpar(it::QPIterator)\n\nRetrieve vector of basis function gradients with respect to the parametric coordinates for the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.QPIterators.bfungrad-Tuple{Elfel.QPIterators.QPIterator,Any}","page":"Reference","title":"Elfel.QPIterators.bfungrad","text":"bfungrad(it::QPIterator, Jac)\n\nRetrieve vector of basis function gradients with respect to spatial coordinates for the current quadrature point.\n\nThe Jacobian matrix maps between vectors in the parametric space and the spatial vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.QPIterators.weight-Tuple{Elfel.QPIterators.QPIterator}","page":"Reference","title":"Elfel.QPIterators.weight","text":"weight(it::QPIterator)\n\nRetrieve weight of the current quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Assemblers","page":"Reference","title":"Assemblers","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.Assemblers]\nPages   = [\"Assemblers.jl\"]","category":"page"},{"location":"man/reference.html#Elfel.Assemblers.AbstractSysmatAssembler","page":"Reference","title":"Elfel.Assemblers.AbstractSysmatAssembler","text":"AbstractSysmatAssembler\n\nAbstract type of system-matrix assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.AbstractSysvecAssembler","text":"AbstractSysvecAssembler\n\nAbstract type of system vector assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysmatAssemblerSparse","page":"Reference","title":"Elfel.Assemblers.SysmatAssemblerSparse","text":"SysmatAssemblerSparse{T<:Number} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from individual entries.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.SysmatAssemblerSparse","text":"SysmatAssemblerSparse(zero::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\nExample\n\nThis is how a sparse matrix is assembled from two rectangular dense matrices.\n\na = SysmatAssemblerSparse(0.0)                                                        \nstart!(a, 7, 7)  \nm = [0.24406   0.599773    0.833404  0.0420141                                             \n0.786024  0.00206713  0.995379  0.780298                                              \n0.845816  0.198459    0.355149  0.224996]     \ngi = [1 7 5]             \ngj = [5 2 1 4]       \nfor j in 1:size(m, 2), i in 1:size(m, 1)\n    assemble!(a, gi[i], gj[j], m[i, j])       \nend  \nm = [0.146618  0.53471   0.614342    0.737833                                              \n0.479719  0.41354   0.00760941  0.836455                                              \n0.254868  0.476189  0.460794    0.00919633                                            \n0.159064  0.261821  0.317078    0.77646                                               \n0.643538  0.429817  0.59788     0.958909]                                   \ngi =  [2 3 1 7 5]\ngj = [6 7 3 4]   \nfor j in 1:size(m, 2), i in 1:size(m, 1)\n    assemble!(a, gi[i], gj[j], m[i, j])       \nend                               \nA = finish!(a) \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.SysvecAssembler","page":"Reference","title":"Elfel.Assemblers.SysvecAssembler","text":"SysvecAssembler\n\nAssembler for the system vector.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.Assemblers.SysvecAssembler-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.SysvecAssembler","text":"SysvecAssembler(zero::T=0.0) where {T<:Number}\n\nConstruct blank system vector assembler. The vector entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Any,Any,T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, r, c, v::T) where {T<:Number}\n\nAssemble a single entry of a rectangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Any,T}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysvecAssembler{T}, i, val::T) where {T<:Number}\n\nAssemble a single value into the row i.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Any}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysvecAssembler{T}, lva) where {T<:Number}\n\nAssemble local vector assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{IT}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T}}} where T<:Number where IT<:Integer","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, lma::LocalMatrixAssembler{IT, T}) where {IT<:Integer, T<:Number}\n\nAssemble the row numbers, column numbers, and values from a local assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{IT}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},LinearAlgebra.Transpose{T,Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T}}}} where T<:Number where IT<:Integer","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, lma::Transpose{T,LocalMatrixAssembler{IT,T}}) where {IT<:Integer, T<:Number}\n\nAssemble the row numbers, column numbers, and values from a local assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.assemble!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Any,T}} where T<:Number where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.assemble!","text":"assemble!(self::SV, i, val::T) where {SV<:AbstractSysvecAssembler, T<:Number}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Tuple{Elfel.Assemblers.SysmatAssemblerSparse}","page":"Reference","title":"Elfel.Assemblers.finish!","text":"finish!(self::SysmatAssemblerSparse)\n\nMake a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Tuple{Elfel.Assemblers.SysvecAssembler}","page":"Reference","title":"Elfel.Assemblers.finish!","text":"finish!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.finish!-Union{Tuple{SV}, Tuple{SV}} where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.finish!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysmatAssemblerSparse{T},Any,Any}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SysmatAssemblerSparse{T}, nrow, ncol) where {T<:Number}\n\nStart the assembly of a global matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{Elfel.Assemblers.SysvecAssembler{T},Int64}} where T<:Number","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SysvecAssembler{T},  nrow::Int64) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nnrow= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.Assemblers.start!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Any}} where T<:Number where SV<:Elfel.Assemblers.AbstractSysvecAssembler","page":"Reference","title":"Elfel.Assemblers.start!","text":"start!(self::SV,  nrow) where {SV<:AbstractSysvecAssembler, T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nnrow= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Local-Assemblers","page":"Reference","title":"Local Assemblers","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Elfel.LocalAssemblers]\nPages   = [\"LocalAssemblers.jl\"]","category":"page"},{"location":"man/reference.html#Base.IndexStyle-Tuple{Type{#s15} where #s15<:Elfel.LocalAssemblers.LocalMatrixAssembler}","page":"Reference","title":"Base.IndexStyle","text":"Base.IndexStyle(::Type{<:LocalMatrixAssembler})\n\nThe data storage is assumed to be consumed best by one-dimensional traversal through the columns in a linear fashion.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.IndexStyle-Tuple{Type{#s15} where #s15<:Elfel.LocalAssemblers.LocalVectorAssembler}","page":"Reference","title":"Base.IndexStyle","text":"Base.IndexStyle(::Type{<:LocalVectorAssembler})\n\nOnly linear access is provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Elfel.LocalAssemblers.LocalMatrixAssembler","text":"LocalMatrixAssembler{IT<:Integer, T<:Number} <: AbstractArray{T, 2}\n\nType of \"local\" matrix assembler.\n\nLocal is to be understood in the sense of in the context of a single finite element. So a local matrix is an elementwise matrix which is computed entry by entry. Then it can be assembled into the global matrix in one shot.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalMatrixAssembler-Union{Tuple{T}, Tuple{IT}, Tuple{IT,IT,T}} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.LocalMatrixAssembler","text":"LocalMatrixAssembler(nrow::IT, ncol::IT, z::T) where {IT, T}\n\nCreate a local matrix assembler, given the number of rows and columns, and the value to which the matrix should be initialized.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Elfel.LocalAssemblers.LocalVectorAssembler","text":"LocalVectorAssembler{IT<:Integer, T<:Number} <: AbstractArray{T, 1}\n\nType of \"local\" vector assembler.\n\nLocal is to be understood in the sense of in the context of a single finite element. So a local vector is an elementwise vector which is computed entry by entry. Then it can be assembled into the global vector in one shot.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elfel.LocalAssemblers.LocalVectorAssembler-Union{Tuple{T}, Tuple{IT}, Tuple{IT,T}} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.LocalVectorAssembler","text":"LocalVectorAssembler(nrow::IT, z::T) where {IT, T}\n\nCreate a local vector assembler, given the number of entries, and the value to which the vector should be initialized.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.getindex-Union{Tuple{A}, Tuple{A,Int64,Int64}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.getindex","text":"Base.getindex(a::A, i::Int, j::Int)\n\nOnly access to a single entry of the matrix is  provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.getindex-Union{Tuple{A}, Tuple{A,Int64}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.getindex","text":"Base.getindex(a::A, i::Int) where {A<:LocalVectorAssembler}\n\nAccess is provided to a single entry of the vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.setindex!-Union{Tuple{A}, Tuple{A,Any,Int64,Int64}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(a::A, v, i::Int, j::Int) where {A<:LocalMatrixAssembler}\n\nOnly access to a single entry of the matrix is  provided.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.setindex!-Union{Tuple{A}, Tuple{A,Any,Int64}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(a::A, v, i::Int) where {A<:LocalVectorAssembler}\n\nAccess is provided to a single entry of the vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.size-Union{Tuple{A}, Tuple{A}} where A<:Elfel.LocalAssemblers.LocalMatrixAssembler","page":"Reference","title":"Base.size","text":"Base.size(a::A) where {A<:LocalMatrixAssembler}\n\nThe size is the tuple of number of rows and number of columns.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Base.size-Union{Tuple{A}, Tuple{A}} where A<:Elfel.LocalAssemblers.LocalVectorAssembler","page":"Reference","title":"Base.size","text":"Base.size(a::A) where {A<:LocalVectorAssembler}\n\nThe size is the number of rows (entries).\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.init!-Union{Tuple{L}, Tuple{T}, Tuple{IT}, Tuple{L,Any,Any}} where L<:Elfel.LocalAssemblers.LocalMatrixAssembler{IT,T} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.init!","text":"init!(a::L, rdofs, cdofs) where {L<:LocalMatrixAssembler{IT, T}} where {IT, T}\n\nInitialize the  local assembler with the global degrees of freedom in the rows and columns.\n\nThe two arrays, rdofs, cdofs, define the global degree of freedom numbers for the element. The data matrix is zeroed out. \n\nThis function needs to be called for each new finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elfel.LocalAssemblers.init!-Union{Tuple{L}, Tuple{T}, Tuple{IT}, Tuple{L,Any}} where L<:Elfel.LocalAssemblers.LocalVectorAssembler{IT,T} where T where IT","page":"Reference","title":"Elfel.LocalAssemblers.init!","text":"init!(a::L, rdofs) where {L<:LocalVectorAssembler{IT, T}} where {IT, T}\n\nInitialize the  local assembler with the global degrees of freedom in the rows.\n\nThe array rdofs defines the global degree of freedom numbers for the element. The data vector is zeroed out. \n\nThis function needs to be called for each new finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Table of contents","category":"page"},{"location":"concepts/concepts.html#Design-and-operation-concepts","page":"Concepts","title":"Design and operation concepts","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Needs to be written.","category":"page"},{"location":"concepts/concepts.html#Why-a-library-of-components","page":"Concepts","title":"Why a library of components","text":"","category":"section"},{"location":"concepts/concepts.html#Basic-types","page":"Concepts","title":"Basic types","text":"","category":"section"},{"location":"concepts/concepts.html#Meshes","page":"Concepts","title":"Meshes","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#How-to-Guide","page":"How to guide","title":"How to Guide","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Needs to be written.","category":"page"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Table of contents","category":"page"},{"location":"tutorials/tutorials.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Heat conduction: Poisson equation. Manufactured solution.\nColliding flow: Stokes equation. Manufactured solution. Hood-Taylor mixed velocity-pressure triangles.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html#Solve-the-Stokes-equation-of-colliding-flow","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"","category":"section"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Synopsis: Compute the solution of the Stokes equation of incompressible viscous flow for a manufactured problem of colliding flow. Hood-Taylor triangular elements are used.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The manufactured-solution colliding flow example from Elman et al 2014. The Hood-Taylor formulation with quadratic triangles for the velocity and continuous pressure on linear triangles.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The formulation is the general elasticity-like scheme with strain-rate-displacement matrices. It can be manipulated into the one derived in Reddy, Introduction to the finite element method, 1993. Page 486 ff.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The complete code is in the file tut_stokes_ht_p2_p1_gen.jl.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"module tut_stokes_ht_p2_p1_gen","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"We'll need some functionality from linear algebra, static arrays, and the mesh libraries. Some plotting will be produced to visualize structure of the stiffness matrix. Finally we will need the Elfel functionality.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"using LinearAlgebra\nusing StaticArrays\nusing MeshCore.Exports\nusing MeshSteward.Exports\nusing Elfel.Exports\nusing UnicodePlots","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The boundary value problem is expressed in this weak form","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":" int_Vunderlinevarepsilon(underlinedelta v)^T\n underlineunderlineD underlinevarepsilon(underlineu) mathrmd V\n- int_V mathrmdiv(underlinedelta v) p mathrmd V = 0quad forall underlinedelta v","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":" - int_V delta q mathrmdiv(underlineu)  mathrmd V = 0quad forall delta q","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Here underlinedelta v are the test functions in the velocity space, and delta q are the pressure test functions. Further underline u is the trial velocity, and p is the trial pressure.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"function run()\n    mu = 1.0 # dynamic viscosity","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"This is the material-property matrix underlineunderlineD:","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    D = SMatrix{3, 3}(\n        [2*mu  0   0\n          0  2*mu  0\n          0    0   mu])\n    A = 1.0 # half of the length of the side of the square\n    N = 100 # number of element edges per side of the square","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"These three functions define the true velocity components and the true pressure.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    trueux = (x, y) -> 20 * x * y ^ 3\n    trueuy = (x, y) -> 5 * x ^ 4 - 5 * y ^ 4\n    truep = (x, y) -> 60 * x ^ 2 * y - 20 * y ^ 3","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Construct the two meshes for the mixed method. They need to support the velocity and pressure spaces.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    vmesh, pmesh = genmesh(A, N)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Constructive velocity space: it is a vector space with two components. The degrees of freedom are real numbers (Float64). The velocity mesh carries the finite elements of  the continuity H ^1, i. e. both the function values and the derivatives are square integrable. Each node carries 2 degrees of freedom, hence there are two velocity components per node.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    Uh = FESpace(Float64, vmesh, FEH1_T6(), 2)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Now we apply the boundary conditions at the nodes around the circumference.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    locs = geometry(vmesh)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"We use searching based on the presence of the node within a box. The entire boundary will be captured within these four boxes, provided we inflate those boxes with a little tolerance (we can't rely on those nodes to be precisely at the coordinates given, we need to introduce some tolerance).","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    boxes = [[-A A -A -A], [-A -A -A A], [A A -A A], [-A A A A]]\n    inflate = A / N / 100\n    for box in boxes\n        vl = vselect(locs; box = box, inflate = inflate)\n        for i in vl","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Remember that all  components of the velocity are known at the boundary.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"            setebc!(Uh, 0, i, 1, trueux(locs[i]...))\n            setebc!(Uh, 0, i, 2, trueuy(locs[i]...))\n        end\n    end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"No we construct the pressure space. It is a continuous, piecewise linear space supported on a mesh of three-node triangles.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    Ph = FESpace(Float64, pmesh, FEH1_T3(), 1)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The pressure in this \"enclosed\" flow example is only known up to a constant. By setting  pressure degree of freedom at one node will make the solution unique.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    atcenter = vselect(geometry(pmesh); nearestto = [0.0, 0.0])\n    setebc!(Ph, 0, atcenter[1], 1, 0.0)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Number the degrees of freedom. First all the free degrees of freedom are numbered, both velocities and pressures. Next all the data degrees of freedom are numbered, again both for the velocities and for the pressures.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    numberdofs!(Uh, Ph)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The total number of degrees of freedom is now calculated.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    tndof = ndofs(Uh) + ndofs(Ph)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"As is the total number of unknowns.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    tnunk = nunknowns(Uh) + nunknowns(Ph)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Assemble the coefficient matrix.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    K = assembleK(Uh, Ph, tndof, D)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Display the structure of the indefinite stiffness matrix. Note that this is the complete matrix, including rows and columns for all the degrees of freedom, unknown and known.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    p = spy(K, canvas = DotCanvas)\n    display(p)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Solve the linear algebraic system. First construct system vector of all the degrees of freedom, in the first tnunk rows that corresponds to the unknowns, and the subsequent rows are for the data degrees of freedom.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    U = fill(0.0, tndof)\n    gathersysvec!(U, [Uh, Ph])","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Note that  the vector U consists of nonzero numbers in rows are for the data degrees of freedom. Multiplying the stiffness matrix with this vector will generate a load vector  on the right-hand side. Otherwise there is no loading, hence the vector F consists of all zeros.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    F = fill(0.0, tndof)\n    solve!(U, K, F, tnunk)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Once we have solved the system of linear equations, we can distribute the solution from the vector U into the finite element spaces.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    scattersysvec!([Uh, Ph], U)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Given that the solution is manufactured, that is exactly known, we can calculate the true errors.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    @show ep = evaluate_pressure_error(Ph, truep)\n    @show ev = evaluate_velocity_error(Uh, trueux, trueuy)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Postprocessing. First we make attributes, scalar nodal attributes, associated with the meshes for the pressures and the velocity.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    makeattribute(Ph, \"p\", 1)\n    makeattribute(Uh, \"ux\", 1)\n    makeattribute(Uh, \"uy\", 2)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The pressure and the velocity components are then written out into two VTK files.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    vtkwrite(\"tut_stokes_ht_p2_p1_gen-p\", baseincrel(pmesh), [(name = \"p\",), ])\n    vtkwrite(\"tut_stokes_ht_p2_p1_gen-v\", baseincrel(vmesh), [(name = \"ux\",), (name = \"uy\",)])","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The  method converges very well, but, why not, here is the true pressure written out into a VTK file as well. We create a synthetic attribute by evaluating the true pressure at the locations of the nodes  of the pressure mesh.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    geom = geometry(Ph.mesh)\n    ir = baseincrel(Ph.mesh)\n    ir.right.attributes[\"pt\"] = VecAttrib([truep(geom[i]...) for i in 1:length(geom)])\n    vtkwrite(\"tut_stokes_ht_p2_p1_gen-pt\", baseincrel(pmesh), [(name = \"pt\",), ])\n\n    return true\nend\n\nfunction genmesh(A, N)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Hood-Taylor pair of meshes is needed. The first mesh is for the velocities, composed of six-node triangles.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    vmesh = attach!(Mesh(), T6block(2 * A, 2 * A, N, N), \"velocity\")","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Now translate so that the center of the square is at the origin of the coordinates.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    ir = baseincrel(vmesh)\n    transform(ir, x -> x .- A)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The second mesh is used for the pressures, and it is composed of three-node triangles such that the corner nodes are shared between the first and the second mesh.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    pmesh = attach!(Mesh(), T6toT3(baseincrel(vmesh, \"velocity\")), \"pressure\")","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"Return the pair of meshes","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"    return vmesh, pmesh\nend\n\nfunction assembleK(Uh, Ph, tndof, D)\n    function integrate!(ass, elits, qpits, D)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The test strain rate vector is calculated as","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"underlinevarepsilon(underlinedelta v) =\n sum_idelta V_i underlineB_c(i)(N_i)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"where c(i) is the number of the component corresponding to the degree of freedom i. This is either 1 when degree of freedom i is the x-component of the velocity, 2 otherwise(for the y-component of the velocity). Analogously for the trial strain rate.","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"The strain-rate matrices are defined as {\\underline{B}{1}(Ni)} = \\left[\\begin{array}{c}      \\partial{Ni}/\\partial{x}  \\\n     0 \\\n     \\partial{Ni}/\\partial{y} \\end{array}\\right],","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"and","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"math {\\underline{B}{2}(Ni)} = \\left[\\begin{array}{c}      0 \\\n     \\partial{Ni}/\\partial{y}  \\\n     \\partial{Ni}/\\partial{x} \\end{array}\\right].","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia         B = (g, k) -> (k == 1 ?             SVector{3}((g[1], 0, g[2])) :             SVector{3}((0, g[2], g[1])))","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThis array defines the components for the element degrees of freedom,\nas defined above as ``c(i)``.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia         c = edofcompnt(Uh)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThese are the totals of the velocity and pressure degrees of freedom\nper element.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia         unedof, pnedof = ndofsperel.((Uh, Ph))","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe local matrix assemblers are used as if they were ordinary\nelementwise dense matrices. Here they are defined.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia         kuu = LocalMatrixAssembler(unedof, unedof, 0.0)         kup = LocalMatrixAssembler(unedof, pnedof, 0.0)         for el in zip(elits...)             uel, pel = el","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe local matrix assemblers are initialized with zeros for the\nvalues, and with the element degree of freedom vectors to be used\nin the assembly. The assembler `kuu` is used for the velocity\ndegrees of freedom, and the assembler `kup` collect the coupling\ncoefficients between the velocity and the pressure.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia             init!(kuu, eldofs(uel), eldofs(uel))             init!(kup, eldofs(uel), eldofs(pel))             for qp in zip(qpits...)                 uqp, pqp = qp","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe integration is performed using the velocity quadrature points.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia                 Jac, J = jacjac(uel, uqp)                 JxW = J * weight(uqp)                 gradNu = bfungrad(uqp, Jac) # gradients of the velocity basis functions                 Np = bfun(pqp) # pressure basis functions","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThis double loop corresponds precisely to the integrals of the\nweak form. This is the  matrix in the upper left corner.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia                 for i in 1:unedof                     DBi = D * B(gradNu[i], c[i])                     for j in 1:unedof                         Bj = B(gradNu[j], c[j])                         kuu[j, i] += dot(Bj, DBi) * (JxW)                     end                 end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nAnd this is the coupling matrix in the top right corner.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia                 for i in 1:pnedof, j in 1:unedof                     kup[j, i] += gradNu[j][c[j]] * (-JxW * Np[i])                 end             end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nAssemble the matrices. The submatrix off the diagonal is assembled\ntwice, once as itself, and once as its transpose.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia             assemble!(ass, kuu)             assemble!(ass, kup) # top right corner             assemble!(ass, transpose(kup)) # bottom left corner         end         return ass     end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nIn the `assembleK` function we first we create the element iterators. We\ncan go through all the elements, both in the velocity finite element\nspace and in the pressure finite element space, that define the domain of\nintegration using this iterator. Each time a new element is accessed,\nsome data are precomputed such as the element degrees of freedom,\ncomponents of the degree of freedom, etc. Note that we need to iterate\ntwo finite element spaces, hence we create a tuple of iterators.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia     elits = (FEIterator(Uh), FEIterator(Ph))","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThese are the quadrature point iterators. We know that the elements are\ntriangular. We choose the three-point rule, to capture the quadratic\ncomponent in the velocity space. Quadrature-point iterators provide\naccess to basis function values and gradients, the Jacobian matrix and\nthe Jacobian determinant, the location of the quadrature point and so\non. Note that we need to iterate the quadrature rules of\ntwo finite element spaces, hence we create a tuple of iterators.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia     qargs = (kind = :default, npts = 3,)     qpits = (QPIterator(Uh, qargs), QPIterator(Ph, qargs))","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe matrix will be assembled into this assembler. Which is initialized\nwith the total number of degrees of freedom (dimension of the coefficient\nmatrix before partitioning into unknowns and data degrees of freedom).\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia     ass = SysmatAssemblerSparse(0.0)     start!(ass, tndof, tndof)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe integration is carried out, and then...\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia     integrate!(ass, elits, qpits, D)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\n...we materialize the sparse stiffness matrix and return it.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia     return finish!(ass) end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"\nThe linear algebraic system is solved by partitioning. The vector `U` is\ninitially all zero, except in the degrees of freedom which are prescribed as\nnonzero. Therefore the product of the stiffness matrix and the vector `U`\nare the loads due to nonzero essential boundary conditions.  The\nsubmatrix of the stiffness conduction matrix corresponding to the free degrees of\nfreedom (unknowns), `K[1:nu, 1:nu]` is then used to solve for the unknowns `U\n[1:nu]`.\n","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"julia function solve!(U, K, F, nu)     KT = K * U     U[1:nu] = K[1:nu, 1:nu] \\ (F[1:nu] - KT[1:nu]) end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"function evaluatepressureerror(Ph, truep)     function integrate!(elit, qpit, truep)         pnedof = ndofsperel(elit)         E = 0.0         for el in elit             dofvals = eldofvals(el)             for qp in qpit                 Jac, J = jacjac(el, qp)                 JxW = J * weight(qp)                 Np = bfun(qp)                 pt = truep(location(el, qp)...)                 pa = 0.0                 for j in 1:pnedof                     pa += (dofvals[j] * Np[j])                 end                 E += (JxW) * (pa - pt)^2             end         end         return sqrt(E)     end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"elit = FEIterator(Ph)\nqargs = (kind = :default, npts = 3,)\nqpit = QPIterator(Ph, qargs)\nreturn integrate!(elit, qpit, truep)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"function evaluatevelocityerror(Uh, trueux, trueuy)     function integrate!(elit, qpit, trueux, trueuy)         unedof = ndofsperel(elit)         uedofcomp = edofcompnt(Uh)         E = 0.0         for el in elit             udofvals = eldofvals(el)             for qp in qpit                 Jac, J = jacjac(el, qp)                 JxW = J * weight(qp)                 Nu = bfun(qp)                 uxt = trueux(location(el, qp)...)                 uyt = trueuy(location(el, qp)...)                 uxa = 0.0                 uya = 0.0                 for j in 1:unedof                     (uedofcomp[j] == 1) && (uxa += (udofvals[j] * Nu[j]))                     (uedofcomp[j] == 2) && (uya += (udofvals[j] * Nu[j]))                 end                 E += (JxW) * ((uxa - uxt)^2 + (uya - uyt)^2)             end         end         return sqrt(E)     end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"elit = FEIterator(Uh)\nqargs = (kind = :default, npts = 3,)\nqpit = QPIterator(Uh, qargs)\nreturn integrate!(elit, qpit, trueux, trueuy)","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"end","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"using .tutstokeshtp2p1gen tutstokeshtp2p1gen.run() ```","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"","category":"page"},{"location":"tutorials/tut_stokes_ht_p2_p1_gen.html","page":"Solve the Stokes equation of colliding flow","title":"Solve the Stokes equation of colliding flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#Elfel-Documentation","page":"Home","title":"Elfel Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Elfel provides support for the development of Finite Element Method applications, especially in the area of continuum mechanics. Mixed methods with cooperating finite element spaces are supported. High performance is one of the focus points.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this package is predicated on the notion that it will provide simple building blocks  to  those who wish to explore the internals of finite element methods.  Hence the focus is on low-level building blocks rather than on prepackaged, high-level, functionality.","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tutorials showing application of the library to some common PDE problems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/tutorials.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#How-to-guide","page":"Home","title":"How to guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The recipes.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Reference-manual","page":"Home","title":"Reference manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and functions.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/reference.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The concepts and ideas are described.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"concepts/concepts.md\",\n]\nDepth = 1","category":"page"}]
}
