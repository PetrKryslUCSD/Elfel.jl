<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solve the Stokes equation of colliding flow: MINI element, general formulation · Elfel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Elfel.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><a class="tocitem" href="../man/reference.html">Reference</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tut_stokes_p1b_p1_gen.html">Solve the Stokes equation of colliding flow: MINI element, general formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tut_stokes_p1b_p1_gen.html">Solve the Stokes equation of colliding flow: MINI element, general formulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Elfel.jl/blob/master/docs/src/tutorials/tut_stokes_p1b_p1_gen.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solve-the-Stokes-equation-of-colliding-flow:-MINI-element,-general-formulation"><a class="docs-heading-anchor" href="#Solve-the-Stokes-equation-of-colliding-flow:-MINI-element,-general-formulation">Solve the Stokes equation of colliding flow: MINI element, general formulation</a><a id="Solve-the-Stokes-equation-of-colliding-flow:-MINI-element,-general-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-Stokes-equation-of-colliding-flow:-MINI-element,-general-formulation" title="Permalink"></a></h1><p>Synopsis: Compute the solution of the Stokes equation of two-dimensional incompressible viscous flow for a manufactured problem of colliding flow. Bubble-function triangular elements are used.</p><p>The &quot;manufactured&quot; colliding flow example from Elman et al 2014. The MINI formulation with linear triangles with a cubic bubble function for the velocity and continuous pressure on linear triangles.</p><p>The pressure is shown here with contours, and the velocities visualized with arrows at random points. <img src="colliding.png" alt="Pressure and velocity"/></p><p>The formulation is the general elasticity-like scheme with strain-rate/velocity matrices. It can be manipulated into the one derived in Reddy, Introduction to the finite element method, 1993. Page 486 ff.</p><p>The complete code is in the file <a href="tut_stokes_p1b_p1_gen.jl"><code>tut_stokes_p1b_p1_gen.jl</code></a>.</p><p>The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.</p><pre><code class="language-julia">module tut_stokes_p1b_p1_gen</code></pre><p>We&#39;ll need some functionality from linear algebra, static arrays, and the mesh libraries. Some plotting will be produced to visualize structure of the stiffness matrix. Finally we will need the <code>Elfel</code> functionality.</p><pre><code class="language-julia">using LinearAlgebra
using StaticArrays
using MeshCore.Exports
using MeshSteward.Exports
using Elfel.Exports
using UnicodePlots</code></pre><p>The boundary value problem is expressed in this weak form</p><div>\[ \int_{V}{\underline{\varepsilon}}(\underline{\delta v})^T\;
 \underline{\underline{D}}\; {\underline{\varepsilon}}(\underline{u})\; \mathrm{d} V
- \int_{V} \mathrm{div}(\underline{\delta v})\; p\; \mathrm{d} V = 0,\quad \forall \underline{\delta v}\]</div><div>\[ - \int_{V} \delta q\; \mathrm{div}(\underline{u}) \; \mathrm{d} V = 0,\quad \forall \delta q\]</div><p>Here <span>$\underline{\delta v}$</span> are the test functions in the velocity space, and <span>$\delta q$</span> are the pressure test functions. Further <span>$\underline {u}$</span> is the trial velocity, and <span>$p$</span> is the trial pressure.</p><pre><code class="language-julia">function run()
    mu = 1.0 # dynamic viscosity</code></pre><p>This is the material-property matrix <span>$\underline{\underline{D}}$</span>:</p><pre><code class="language-julia">    D = SMatrix{3, 3}(
        [2*mu  0   0
          0  2*mu  0
          0    0   mu])
    A = 1.0 # half of the length of the side of the square
    N = 100 # number of element edges per side of the square</code></pre><p>These three functions define the true velocity components and the true pressure.</p><pre><code class="language-julia">    trueux = (x, y) -&gt; 20 * x * y ^ 3
    trueuy = (x, y) -&gt; 5 * x ^ 4 - 5 * y ^ 4
    truep = (x, y) -&gt; 60 * x ^ 2 * y - 20 * y ^ 3</code></pre><p>Construct the two meshes for the mixed method. They need to support the velocity and pressure spaces.</p><pre><code class="language-julia">    mesh = genmesh(A, N)</code></pre><p>Construct the velocity space: it is a vector space with two components. The degrees of freedom are real numbers (<code>Float64</code>). The velocity mesh carries the finite elements of  the continuity <span>$H ^1$</span>, i. e. both the function values and the derivatives are square integrable. Each node carries 2 degrees of freedom, hence there are two velocity components per node.</p><pre><code class="language-julia">    Uh = FESpace(Float64, mesh, FEH1_T3_BUBBLE(), 2)</code></pre><p>Now we apply the boundary conditions at the nodes around the circumference.</p><pre><code class="language-julia">    locs = geometry(mesh)</code></pre><p>We use searching based on the presence of the node within a box. The entire boundary will be captured within these four boxes, provided we inflate those boxes with a little tolerance (we can&#39;t rely on those nodes to be precisely at the coordinates given, we need to introduce some tolerance).</p><pre><code class="language-julia">    boxes = [[-A A -A -A], [-A -A -A A], [A A -A A], [-A A A A]]
    inflate = A / N / 100
    for box in boxes
        vl = vselect(locs; box = box, inflate = inflate)
        for i in vl</code></pre><p>Remember that all  components of the velocity are known at the boundary.</p><pre><code class="language-julia">            setebc!(Uh, 0, i, 1, trueux(locs[i]...))
            setebc!(Uh, 0, i, 2, trueuy(locs[i]...))
        end
    end</code></pre><p>No we construct the pressure space. It is a continuous, piecewise linear space supported on a mesh of three-node triangles.</p><pre><code class="language-julia">    Ph = FESpace(Float64, mesh, FEH1_T3(), 1)</code></pre><p>The pressure in this &quot;enclosed&quot; flow example is only known up to a constant. By setting  pressure degree of freedom at one node will make the solution unique.</p><pre><code class="language-julia">    atcenter = vselect(geometry(mesh); nearestto = [0.0, 0.0])
    setebc!(Ph, 0, atcenter[1], 1, 0.0)</code></pre><p>Number the degrees of freedom. First all the free degrees of freedom are numbered, both velocities and pressures. Next all the data degrees of freedom are numbered, again both for the velocities and for the pressures.</p><pre><code class="language-julia">    numberdofs!([Uh, Ph])</code></pre><p>The total number of degrees of freedom is now calculated.</p><pre><code class="language-julia">    tndof = ndofs(Uh) + ndofs(Ph)</code></pre><p>As is the total number of unknowns.</p><pre><code class="language-julia">    tnunk = nunknowns(Uh) + nunknowns(Ph)</code></pre><p>Assemble the coefficient matrix.</p><pre><code class="language-julia">    K = assembleK(Uh, Ph, tndof, D)</code></pre><p>Display the structure of the indefinite stiffness matrix. Note that this is the complete matrix, including rows and columns for all the degrees of freedom, unknown and known.</p><pre><code class="language-julia">    p = spy(K, canvas = DotCanvas)
    display(p)</code></pre><p>Solve the linear algebraic system. First construct system vector of all the degrees of freedom, in the first <code>tnunk</code> rows that corresponds to the unknowns, and the subsequent rows are for the data degrees of freedom.</p><pre><code class="language-julia">    U = fill(0.0, tndof)
    gathersysvec!(U, [Uh, Ph])</code></pre><p>Note that  the vector <code>U</code> consists of nonzero numbers in rows are for the data degrees of freedom. Multiplying the stiffness matrix with this vector will generate a load vector  on the right-hand side. Otherwise there is no loading, hence the vector <code>F</code> consists of all zeros.</p><pre><code class="language-julia">    F = fill(0.0, tndof)
    solve!(U, K, F, tnunk)</code></pre><p>Once we have solved the system of linear equations, we can distribute the solution from the vector <code>U</code> into the finite element spaces.</p><pre><code class="language-julia">    scattersysvec!([Uh, Ph], U)</code></pre><p>Given that the solution is manufactured, i. e. exactly known, we can calculate the true errors.</p><pre><code class="language-julia">    @show ep = evaluate_pressure_error(Ph, truep)
    @show ev = evaluate_velocity_error(Uh, trueux, trueuy)</code></pre><p>Postprocessing. First we make attributes, scalar nodal attributes, associated with the meshes for the pressures and the velocity.</p><pre><code class="language-julia">    makeattribute(Ph, &quot;p&quot;, 1)
    makeattribute(Uh, &quot;ux&quot;, 1)
    makeattribute(Uh, &quot;uy&quot;, 2)</code></pre><p>The pressure and the velocity components are then written out into two VTK files.</p><pre><code class="language-julia">    vtkwrite(&quot;tut_stokes_p1b_p1_gen-p&quot;, baseincrel(mesh), [(name = &quot;p&quot;,), ])
    vtkwrite(&quot;tut_stokes_p1b_p1_gen-v&quot;, baseincrel(mesh), [(name = &quot;ux&quot;,), (name = &quot;uy&quot;,)])

    return true
end

function genmesh(A, N)</code></pre><p>Linear triangle mesh is used for both the velocity space and the pressure space.</p><pre><code class="language-julia">    mesh = attach!(Mesh(), T3block(2 * A, 2 * A, N, N), &quot;velocity&quot;)</code></pre><p>Now translate so that the center of the square is at the origin of the coordinates.</p><pre><code class="language-julia">    ir = baseincrel(mesh)
    transform(ir, x -&gt; x .- A)</code></pre><p>The bubble degree of freedom is associated with the element itself. The mesh will therefore be equipped with the incidence relation <span>$(2, 2)$</span>. The finite element space for the velocity will therefore have degrees of freedom associated with the vertices and with the faces (elements themselves). The finite element space does that by associating fields with incidence relations, hence the need for this one.</p><pre><code class="language-julia">    eidir = ir_identity(ir)
    attach!(mesh, eidir)
    return mesh
end

function assembleK(Uh, Ph, tndof, D)
    function integrate!(ass, elits, qpits, D)</code></pre><p>Consider the elementwise definition of the test strain rate, <span>${\underline{\varepsilon}}(\underline{\delta v})$</span>. It is calculated from the elementwise degrees of freedom and the associated basis functions  as</p><div>\[{\underline{\varepsilon}}(\underline{\delta v}) =
 \sum_i{\delta V}_i {\underline{B}_{c(i)}(N_i)}\]</div><p>where <span>$i = 1, \ldots, n_{du}$</span>, and <span>$n_{du}$</span> is the number of velocity degrees of freedom per element, <span>$c(i)$</span> is the number of the component corresponding to the degree of freedom <span>$i$</span>. This is either 1 when degree of freedom <span>$i$</span> is the <span>$x$</span>-component of the velocity, 2 otherwise(for the <span>$y$</span>-component of the velocity). Analogously for the trial strain rate.</p><p>The strain-rate/velocity matrices are defined as</p><div>\[{\underline{B}_{1}(N_i)} =
\left[\begin{array}{c}
     \partial{N_i}/\partial{x}  \\
     0 \\
     \partial{N_i}/\partial{y}
\end{array}\right],\]</div><p>and</p><div>\[{\underline{B}_{2}(N_i)} =
\left[\begin{array}{c}
     0 \\
     \partial{N_i}/\partial{y}  \\
     \partial{N_i}/\partial{x}
\end{array}\right].\]</div><p>This tiny function evaluates the strain-rate/velocity matrices defined above from the gradient of a basis function and the given number of the component corresponding to the current degree of freedom.</p><pre><code class="language-julia">        B = (g, k) -&gt; (k == 1 ?
            SVector{3}((g[1], 0, g[2])) :
            SVector{3}((0, g[2], g[1])))</code></pre><p>This array defines the components for the element degrees of freedom, as defined above as <span>$c(i)$</span>.</p><pre><code class="language-julia">        c = edofcompnt(Uh)</code></pre><p>These are the totals of the velocity and pressure degrees of freedom per element.</p><pre><code class="language-julia">        n_du, n_dp = ndofsperel.((Uh, Ph))</code></pre><p>The local matrix assemblers are used as if they were ordinary elementwise dense matrices. Here they are defined.</p><pre><code class="language-julia">        kuu = LocalMatrixAssembler(n_du, n_du, 0.0)
        kup = LocalMatrixAssembler(n_du, n_dp, 0.0)
        for el in zip(elits...)
            uel, pel = el</code></pre><p>The local matrix assemblers are initialized with zeros for the values, and with the element degree of freedom vectors to be used in the assembly. The assembler <code>kuu</code> is used for the velocity degrees of freedom, and the assembler <code>kup</code> collect the coupling coefficients between the velocity and the pressure. The function <code>eldofs</code> collects the global numbers of the degrees of freedom either for the velocity space, or for the pressure space (<code>eldofs(pel)</code>).</p><pre><code class="language-julia">            init!(kuu, eldofs(uel), eldofs(uel))
            init!(kup, eldofs(uel), eldofs(pel))
            for qp in zip(qpits...)
                uqp, pqp = qp</code></pre><p>The integration is performed using the velocity quadrature points.</p><pre><code class="language-julia">                Jac, J = jacjac(uel, uqp)
                JxW = J * weight(uqp)
                gradNu = bfungrad(uqp, Jac) # gradients of the velocity basis functions
                Np = bfun(pqp) # pressure basis functions</code></pre><p>This double loop corresponds precisely to the integrals of the weak form. This is the  matrix in the upper left corner.</p><pre><code class="language-julia">                for i in 1:n_du
                    DBi = D * B(gradNu[i], c[i])
                    for j in 1:n_du
                        Bj = B(gradNu[j], c[j])
                        kuu[j, i] += dot(Bj, DBi) * (JxW)
                    end
                end</code></pre><p>And this is the coupling matrix in the top right corner.</p><pre><code class="language-julia">                for i in 1:n_dp, j in 1:n_du
                    kup[j, i] += gradNu[j][c[j]] * (-JxW * Np[i])
                end
            end</code></pre><p>Assemble the matrices. The submatrix off the diagonal is assembled twice, once as itself, and once as its transpose.</p><pre><code class="language-julia">            assemble!(ass, kuu)
            assemble!(ass, kup) # top right corner
            assemble!(ass, transpose(kup)) # bottom left corner
        end
        return ass # return the updated assembler of the global matrix
    end</code></pre><p>In the <code>assembleK</code> function we first we create the element iterators. We can go through all the elements, both in the velocity finite element space and in the pressure finite element space, that define the domain of integration using this iterator. Each time a new element is accessed, some data are precomputed such as the element degrees of freedom, components of the degree of freedom, etc. Note that we need to iterate two finite element spaces, hence we create a tuple of iterators.</p><pre><code class="language-julia">    elits = (FEIterator(Uh), FEIterator(Ph))</code></pre><p>These are the quadrature point iterators. We know that the elements are triangular. We choose the three-point rule, to capture the quadratic component in the velocity space. Quadrature-point iterators provide access to basis function values and gradients, the Jacobian matrix and the Jacobian determinant, the location of the quadrature point and so on. Note that we need to iterate the quadrature rules of two finite element spaces, hence we create a tuple of iterators.</p><pre><code class="language-julia">    qargs = (kind = :default, npts = 3,)
    qpits = (QPIterator(Uh, qargs), QPIterator(Ph, qargs))</code></pre><p>The matrix will be assembled into this assembler. Which is initialized with the total number of degrees of freedom (dimension of the coefficient matrix before partitioning into unknowns and data degrees of freedom).</p><pre><code class="language-julia">    ass = SysmatAssemblerSparse(0.0)
    start!(ass, tndof, tndof)</code></pre><p>The integration is carried out, and then...</p><pre><code class="language-julia">    integrate!(ass, elits, qpits, D)</code></pre><p>...we materialize the sparse stiffness matrix and return it.</p><pre><code class="language-julia">    return finish!(ass)
end</code></pre><p>The linear algebraic system is solved by partitioning. The vector <code>U</code> is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the stiffness matrix and the vector <code>U</code> are the loads due to nonzero essential boundary conditions.  The submatrix of the stiffness conduction matrix corresponding to the free degrees of freedom (unknowns), <code>K[1:nu, 1:nu]</code> is then used to solve for the unknowns <code>U [1:nu]</code>.</p><pre><code class="language-julia">function solve!(U, K, F, nu)
    KT = K * U
    U[1:nu] = K[1:nu, 1:nu] \ (F[1:nu] - KT[1:nu])
end</code></pre><p>The function <code>evaluate_pressure_error</code> evaluates the true <span>$L^2$</span>  error of the pressure. It does that by integrating the square of the difference between the approximate pressure and the  true pressure, the true pressure being provided by the <code>truep</code> function.</p><pre><code class="language-julia">function evaluate_pressure_error(Ph, truep)
    function integrate!(elit, qpit, truep)
        n_dp = ndofsperel(elit)
        E = 0.0
        for el in elit
            dofvals = eldofvals(el)
            for qp in qpit
                Jac, J = jacjac(el, qp)
                JxW = J * weight(qp)
                Np = bfun(qp)
                pt = truep(location(el, qp)...)
                pa = 0.0
                for j in 1:n_dp
                    pa += (dofvals[j] * Np[j])
                end
                E += (JxW) * (pa - pt)^2
            end
        end
        return sqrt(E)
    end

    elit = FEIterator(Ph)
    qargs = (kind = :default, npts = 3,)
    qpit = QPIterator(Ph, qargs)
    return integrate!(elit, qpit, truep)
end</code></pre><p>The function <code>evaluate_velocity_error</code> evaluates the true <span>$L^2$</span>  error of the velocity. It does that by integrating the square of the difference between the approximate pressure and the  true velocity, the true velocity being provided by the <code>trueux</code>, <code>trueuy</code> functions.</p><pre><code class="language-julia">function evaluate_velocity_error(Uh, trueux, trueuy)
    function integrate!(elit, qpit, trueux, trueuy)
        n_du = ndofsperel(elit)
        uedofcomp = edofcompnt(Uh)
        E = 0.0
        for el in elit
            udofvals = eldofvals(el)
            for qp in qpit
                Jac, J = jacjac(el, qp)
                JxW = J * weight(qp)
                Nu = bfun(qp)
                uxt = trueux(location(el, qp)...)
                uyt = trueuy(location(el, qp)...)
                uxa = 0.0
                uya = 0.0
                for j in 1:n_du
                    (uedofcomp[j] == 1) &amp;&amp; (uxa += (udofvals[j] * Nu[j]))
                    (uedofcomp[j] == 2) &amp;&amp; (uya += (udofvals[j] * Nu[j]))
                end
                E += (JxW) * ((uxa - uxt)^2 + (uya - uyt)^2)
            end
        end
        return sqrt(E)
    end

    elit = FEIterator(Uh)
    qargs = (kind = :default, npts = 3,)
    qpit = QPIterator(Uh, qargs)
    return integrate!(elit, qpit, trueux, trueuy)
end

end</code></pre><p>To run the example, evaluate this file which will  compile the module <code>.tut_stokes_p1b_p1_gen</code>.</p><pre><code class="language-julia">using .tut_stokes_p1b_p1_gen
tut_stokes_p1b_p1_gen.run()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 September 2020 03:04">Tuesday 15 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
