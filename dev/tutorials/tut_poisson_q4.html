<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solve the heat conduction equation · Elfel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Elfel.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><a class="tocitem" href="../man/reference.html">Reference</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tut_poisson_q4.html">Solve the heat conduction equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tut_poisson_q4.html">Solve the heat conduction equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Elfel.jl/blob/master/docs/src/tutorials/tut_poisson_q4.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solve-the-heat-conduction-equation"><a class="docs-heading-anchor" href="#Solve-the-heat-conduction-equation">Solve the heat conduction equation</a><a id="Solve-the-heat-conduction-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-heat-conduction-equation" title="Permalink"></a></h1><p>Synopsis: Compute the solution of the Poisson equation of heat conduction with a nonzero heat source. Quadrilateral four-node elements are used.</p><p>The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.</p><p>The complete code is in the file <a href="tut_poisson_q4.jl">tut<em>poisson</em>q4.jl</a>.</p><pre><code class="language-julia">module tut_poisson_q4</code></pre><p>We&#39;ll need some functionality from linear algebra, and the mesh libraries.</p><pre><code class="language-julia">using LinearAlgebra
using MeshCore.Exports
using MeshSteward.Exports
using Elfel.Exports</code></pre><p>This is the top level function.</p><pre><code class="language-julia">function run()</code></pre><p>Input parameters:</p><pre><code class="language-julia">    A = 1.0 # length of the side of the square
    kappa =  1.0; # thermal conductivity of the material
    Q = -6.0; # internal heat generation rate
    tempf(x, y) =(1.0 + x^2 + 2.0 * y^2); # the exact distribution of temperature
    N = 1000; # number of element edges along the sides of the square domain</code></pre><p>Generate the computational mesh.</p><pre><code class="language-julia">    mesh = genmesh(A, N)</code></pre><p>Create the finite element space to represent the temperature solution.</p><pre><code class="language-julia">    Uh = FESpace(Float64, mesh, FEH1_Q4())</code></pre><p>Apply the essential boundary conditions at the circumference of the square domain.</p><pre><code class="language-julia">    bir = boundary(mesh);
    vl = connectedv(bir);
    locs = geometry(mesh)
    for i in vl
        setebc!(Uh, 0, i, 1, tempf(locs[i]...))
    end</code></pre><p>Number the degrees of freedom, both the unknowns and the data (prescribed) degrees of freedom.</p><pre><code class="language-julia">    numberdofs!(Uh)
    @show ndofs(Uh), nunknowns(Uh)</code></pre><p>Assemble the conductivity matrix and the vector of the heat loads.</p><pre><code class="language-julia">    K, F = assembleKF(Uh, kappa, Q)</code></pre><p>This is a vector to hold all degrees of freedom in the system.</p><pre><code class="language-julia">    T = fill(0.0, ndofs(Uh))</code></pre><p>Here we collect the data degrees of freedom (the known values).</p><pre><code class="language-julia">    gathersysvec!(T, Uh)</code></pre><p>The system of linear algebraic equations is solved.</p><pre><code class="language-julia">    solve!(T, K, F, nunknowns(Uh))</code></pre><p>The values of all the degrees of freedom can now be introduced into the finite element space.</p><pre><code class="language-julia">    scattersysvec!(Uh, T)</code></pre><p>Here we associate the values of the finite element with the entities of the mesh as an attribute.</p><pre><code class="language-julia">    makeattribute(Uh, &quot;T&quot;, 1)</code></pre><p>The correctness of the solution is checked by comparing the values at the vertices.</p><pre><code class="language-julia">    checkcorrectness(Uh, tempf)</code></pre><p>The attribute can now be written out for visualization into a VTK file.</p><pre><code class="language-julia">    vtkwrite(&quot;q4-T&quot;, baseincrel(mesh), [(name = &quot;T&quot;,)])

    true # return success
end</code></pre><p>The domain is a square, meshed with quadrilateral elements.</p><pre><code class="language-julia">function genmesh(A, N)
    conn = Q4block(A, A, N, N)
    return attach!(Mesh(), conn)
end

function assembleKF(Uh, kappa, Q)
    function integrate!(am, av, elit, qpit, kappa, Q)
        nedof = ndofsperel(elit)
        ke = LocalMatrixAssembler(nedof, nedof, 0.0)
        fe = LocalVectorAssembler(nedof, 0.0)
        for el in elit
            init!(ke, eldofs(el), eldofs(el))
            init!(fe, eldofs(el))
            for qp in qpit
                Jac, J = jacjac(el, qp)
                gradN = bfungrad(qp, Jac)
                JxW = J * weight(qp)
                N = bfun(qp)
                for j in 1:nedof
                    for i in 1:nedof
                        ke[i, j] += dot(gradN[i], gradN[j]) * (kappa * JxW)
                    end
                    fe[j] += N[j] * Q * JxW
                end
            end
            assemble!(am, ke)
            assemble!(av, fe)
        end
        return am, av
    end

    elit = FEIterator(Uh)
    qpit = QPIterator(Uh, (kind = :Gauss, order = 2))
    am = start!(SysmatAssemblerSparse(0.0), ndofs(Uh), ndofs(Uh))
    av = start!(SysvecAssembler(0.0), ndofs(Uh))

    @time integrate!(am, av, elit, qpit, kappa, Q)

    return finish!(am), finish!(av)
end</code></pre><p>The linear algebraic system is solved by partitioning. The vector <code>T</code> is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the conductivity matrix and the vector <code>T</code> are the heat loads due to nonzero essential boundary conditions. To this we add the vector of heat loads due to the internal heat generation rate. The submatrix of the heat conduction matrix corresponding to the free degrees of freedom (unknowns), <code>K[1:nu, 1:nu]</code> is then used to solve for the unknowns <code>T [1:nu]</code>.</p><pre><code class="language-julia">function solve!(T, K, F, nu)
    @time KT = K * T
    @time T[1:nu] = K[1:nu, 1:nu] \ (F[1:nu] - KT[1:nu])
end

function checkcorrectness(Uh, tempf)
    geom = geometry(Uh.mesh)
    ir = baseincrel(Uh.mesh)
    T = attribute(ir.right, &quot;T&quot;)
    std = 0.0
    for i in 1:length(T)
        std += abs(T[i][1] - tempf(geom[i]...))
    end
    @show (std / length(T)) &lt;= 1.0e-9
end

end # module

using .tut_poisson_q4
tut_poisson_q4.run()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 11 July 2020 23:15">Saturday 11 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
