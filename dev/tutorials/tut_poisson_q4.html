<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solve the heat conduction equation · Elfel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Elfel.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><a class="tocitem" href="../man/reference.html">Reference</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tut_poisson_q4.html">Solve the heat conduction equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tut_poisson_q4.html">Solve the heat conduction equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Elfel.jl/blob/master/docs/src/tutorials/tut_poisson_q4.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solve-the-heat-conduction-equation"><a class="docs-heading-anchor" href="#Solve-the-heat-conduction-equation">Solve the heat conduction equation</a><a id="Solve-the-heat-conduction-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-heat-conduction-equation" title="Permalink"></a></h1><p>Synopsis: Compute the solution of the Poisson equation of heat conduction with a nonzero heat source. Quadrilateral four-node elements are used.</p><p>The problem is linear heat conduction equation posed on a bi-unit square, solved with Dirichlet boundary conditions around the circumference. Uniform nonzero heat generation rate is present. The exact solution is in this way manufactured and hence known. That gives us an opportunity to calculate the true error.</p><p>The complete code is in the file <a href="tut_poisson_q4.jl"><code>tut_poisson_q4.jl</code></a>.</p><p>The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.</p><pre><code class="language-julia">module tut_poisson_q4</code></pre><p>We&#39;ll need some functionality from linear algebra, and the mesh libraries. Finally we will need the <code>Elfel</code> functionality.</p><pre><code class="language-julia">using LinearAlgebra
using MeshCore.Exports
using MeshSteward.Exports
using Elfel.Exports</code></pre><p>This is the top level function.</p><pre><code class="language-julia">function run()</code></pre><p>Input parameters:</p><pre><code class="language-julia">    A = 1.0 # length of the side of the square
    kappa =  1.0; # thermal conductivity of the material
    Q = -6.0; # internal heat generation rate
    tempf(x, y) =(1.0 + x^2 + 2.0 * y^2); # the exact distribution of temperature
    N = 1000; # number of element edges along the sides of the square domain</code></pre><p>Generate the computational mesh.</p><pre><code class="language-julia">    mesh = genmesh(A, N)</code></pre><p>Create the finite element space to represent the temperature solution. The degrees of freedom are real numbers (<code>Float64</code>), the quadrilaterals are defined by the mesh, and each of the elements has the continuity <span>$H ^1$</span>, i. e. both the function values and the derivatives are square integrable.</p><pre><code class="language-julia">    Uh = FESpace(Float64, mesh, FEH1_Q4())</code></pre><p>Apply the essential boundary conditions at the circumference of the square domain. We find the boundary incidence relation (<code>boundary(mesh)</code>), and then the list of all vertices connected by the boundary cells. The function <code>tempf</code> defines the analytical temperature variation, and hence for each of the vertices <code>i</code> on the boundary (they are of manifold dimension  <code>0</code>), we set the component of the field (1) to the exact value of the temperature at that location.</p><pre><code class="language-julia">    vl = connectedv(boundary(mesh));
    locs = geometry(mesh)
    for i in vl
        setebc!(Uh, 0, i, 1, tempf(locs[i]...))
    end</code></pre><p>Number the degrees of freedom, both the unknowns and the data (prescribed) degrees of freedom.</p><pre><code class="language-julia">    numberdofs!(Uh)
    @show ndofs(Uh), nunknowns(Uh)</code></pre><p>Assemble the conductivity matrix and the vector of the heat loads. Refer to the definition of this function below.</p><pre><code class="language-julia">    K, F = assembleKF(Uh, kappa, Q)</code></pre><p>This is a vector to hold all degrees of freedom in the system.</p><pre><code class="language-julia">    T = fill(0.0, ndofs(Uh))</code></pre><p>Here we collect the data degrees of freedom (the known values).</p><pre><code class="language-julia">    gathersysvec!(T, Uh)</code></pre><p>The system of linear algebraic equations is solved.</p><pre><code class="language-julia">    solve!(T, K, F, nunknowns(Uh))</code></pre><p>The values of all the degrees of freedom can now be introduced into the finite element space.</p><pre><code class="language-julia">    scattersysvec!(Uh, T)</code></pre><p>Here we associate the values of the finite element space with the entities of the mesh as an attribute.</p><pre><code class="language-julia">    makeattribute(Uh, &quot;T&quot;, 1)</code></pre><p>The correctness of the solution is checked by comparing the values at the vertices.</p><pre><code class="language-julia">    checkcorrectness(Uh, tempf)</code></pre><p>The attribute can now be written out for visualization into a VTK file.</p><pre><code class="language-julia">    vtkwrite(&quot;q4-T&quot;, baseincrel(mesh), [(name = &quot;T&quot;,)])

    true # return success
end</code></pre><p>The domain is a square, meshed with quadrilateral elements. The function <code>Q4block</code> creates an incidence relation that defines the quadrilateral element shapes by the vertices connected into the shapes. This incidence relation is then attached to the mesh and the mesh is returned.</p><pre><code class="language-julia">function genmesh(A, N)
    conn = Q4block(A, A, N, N)
    return attach!(Mesh(), conn)
end</code></pre><p>The <code>assembleKF</code> function constructs the left-hand side coefficient matrix, conductivity matrix, as a sparse matrix, and a vector of the heat loads due to the internal heat generation rate <code>Q</code>.</p><p>The boundary value problem is expressed in this weak form</p><div>\[\int_{V}(\mathrm{grad}\vartheta)\; \kappa (\mathrm{grad}T
            )^T\; \mathrm{d} V
            -\int_{V}  \vartheta Q \; \mathrm{d} V
             = 0\]</div><p>where the test function vanishes on the boundary where the temperature is prescribed, <span>$\vartheta(x) =0$</span>  for  <span>$x \in{S_1}$</span> Substituting <span>$\vartheta = N_j$</span> and <span>$T = \sum_i N_i T_i$</span> we obtain the linear algebraic equations</p><div>\[\sum_i T_i \int_{V} \mathrm{grad}N_j \; \kappa (\mathrm{grad}N_i)^T\; \mathrm{d} V
 -\int_{V}  N_j Q \; \mathrm{d} V  = 0 , \quad \forall j.\]</div><p>The volume element is <span>$\mathrm{d} V$</span>, which in our case becomes <span>$1.0\times\mathrm{d} S$</span>, since the thickness of the two dimensional domain is assumed to be 1.0.</p><pre><code class="language-julia">function assembleKF(Uh, kappa, Q)</code></pre><p>At the top of the <code>assembleKF</code> we look at the function <code>integrate!</code> to evaluate the weak-form integrals. The key to making this calculation efficient is type stability. All the arguments coming in must have concrete types. This is why the <code>integrate!</code> function is an inner function: the function barrier allows for all arguments to be resolved to concrete types.</p><pre><code class="language-julia">    function integrate!(am, av, elit, qpit, kappa, Q)
        nedof = ndofsperel(elit)</code></pre><p>The local assemblers are just like matrices or vectors</p><pre><code class="language-julia">        ke = LocalMatrixAssembler(nedof, nedof, 0.0)
        fe = LocalVectorAssembler(nedof, 0.0)
        for el in elit # Loop over all elements
            init!(ke, eldofs(el), eldofs(el)) # zero out elementwise matrix
            init!(fe, eldofs(el)) # and vector
            for qp in qpit # Now loop over the quadrature points
                Jac, J = jacjac(el, qp) # Calculate the Jacobian matrix, Jacobian
                gradN = bfungrad(qp, Jac) # Evaluate the spatial gradients
                JxW = J * weight(qp) # elementary volume
                N = bfun(qp) # Basis function values at the quadrature point</code></pre><p>This double loop evaluates the elementwise conductivity matrix and the heat load vector precisely as the formula of the weak form  dictates; see above.</p><pre><code class="language-julia">                for i in 1:nedof
                    for j in 1:nedof
                        ke[j, i] += dot(gradN[j], gradN[i]) * (kappa * JxW)
                    end
                    fe[j] += N[j] * Q * JxW
                end
            end</code></pre><p>Assemble the calculated contributions from this element</p><pre><code class="language-julia">            assemble!(am, ke)
            assemble!(av, fe)
        end
        return am, av # Return the updated assemblers
    end</code></pre><p>In the <code>assembleKF</code> function we first we create the element iterator. We can go through all the elements that define the domain of integration using this iterator. Each time a new element is accessed, some data are precomputed such as the element degrees of freedom.</p><pre><code class="language-julia">    elit = FEIterator(Uh)</code></pre><p>This is the quadrature point iterator. We know that the elements are quadrilateral, which makes the Gauss integration rule the obvious choice. We also select order 2 for accuracy. Quadrature-point iterators provide access to basis function values and gradients, the Jacobian matrix and the Jacobian determinant, the location of the quadrature point and so on.</p><pre><code class="language-julia">    qpit = QPIterator(Uh, (kind = :Gauss, order = 2))</code></pre><p>Next we create assemblers, one for the sparse system matrix and one for the system vector.</p><pre><code class="language-julia">    am = start!(SysmatAssemblerSparse(0.0), ndofs(Uh), ndofs(Uh))
    av = start!(SysvecAssembler(0.0), ndofs(Uh))</code></pre><p>Now we call the integration function. The assemblers are modified inside this function...</p><pre><code class="language-julia">    @time integrate!(am, av, elit, qpit, kappa, Q)</code></pre><p>...so that when the integration is done, we can materialize the sparse matrix and the vector and return them.</p><pre><code class="language-julia">    return finish!(am), finish!(av)
end</code></pre><p>The linear algebraic system is solved by partitioning. The vector <code>T</code> is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the conductivity matrix and the vector <code>T</code> are the heat loads due to nonzero essential boundary conditions. To this we add the vector of heat loads due to the internal heat generation rate. The submatrix of the heat conduction matrix corresponding to the free degrees of freedom (unknowns), <code>K[1:nu, 1:nu]</code> is then used to solve for the unknowns <code>T [1:nu]</code>.</p><pre><code class="language-julia">function solve!(T, K, F, nu)
    @time KT = K * T
    @time T[1:nu] = K[1:nu, 1:nu] \ (F[1:nu] - KT[1:nu])
end</code></pre><p>The correctness can be checked in various ways. Here we calculate the mean deviation of the calculated temperatures at the nodes relative to the exact values of the temperature.</p><pre><code class="language-julia">function checkcorrectness(Uh, tempf)
    geom = geometry(Uh.mesh)
    ir = baseincrel(Uh.mesh)
    T = attribute(ir.right, &quot;T&quot;)
    std = 0.0
    for i in 1:length(T)
        std += abs(T[i][1] - tempf(geom[i]...))
    end
    @show (std / length(T)) &lt;= 1.0e-9
end

end # module</code></pre><p>The module can now be used.</p><pre><code class="language-julia">using .tut_poisson_q4
tut_poisson_q4.run()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 July 2020 01:42">Monday 13 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
