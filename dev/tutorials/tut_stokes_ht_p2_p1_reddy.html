<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solve the Stokes equation of colliding flow: Reddy formulation · Elfel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Elfel.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><a class="tocitem" href="../man/reference.html">Reference</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tut_stokes_ht_p2_p1_reddy.html">Solve the Stokes equation of colliding flow: Reddy formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tut_stokes_ht_p2_p1_reddy.html">Solve the Stokes equation of colliding flow: Reddy formulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Elfel.jl/blob/master/docs/src/tutorials/tut_stokes_ht_p2_p1_reddy.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solve-the-Stokes-equation-of-colliding-flow:-Reddy-formulation"><a class="docs-heading-anchor" href="#Solve-the-Stokes-equation-of-colliding-flow:-Reddy-formulation">Solve the Stokes equation of colliding flow: Reddy formulation</a><a id="Solve-the-Stokes-equation-of-colliding-flow:-Reddy-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-Stokes-equation-of-colliding-flow:-Reddy-formulation" title="Permalink"></a></h1><p>Synopsis: Compute the solution of the Stokes equation of two-dimensional incompressible viscous flow for a manufactured problem of colliding flow. Hood-Taylor triangular elements are used.</p><p>The &quot;manufactured&quot; colliding flow example from Elman et al 2014. The Hood-Taylor formulation with quadratic triangles for the velocity and continuous pressure on linear triangles.</p><p>The pressure is shown here with contours, and the velocities visualized with arrows at random points. <img src="colliding.png" alt="Pressure and velocity"/></p><p>The formulation is the one derived in Reddy, Introduction to the finite element method, 1993. Page 486 ff.</p><p>The complete code is in the file <a href="tut_stokes_ht_p2_p1_reddy.jl"><code>tut_stokes_ht_p2_p1_reddy.jl</code></a>.</p><p>The solution will be defined  within a module in order to eliminate conflicts with data or functions defined elsewhere.</p><pre><code class="language-julia">module tut_stokes_ht_p2_p1_reddy</code></pre><p>We&#39;ll need some functionality from linear algebra, static arrays, and the mesh libraries. Some plotting will be produced to visualize structure of the stiffness matrix. Finally we will need the <code>Elfel</code> functionality.</p><pre><code class="language-julia">using LinearAlgebra
using StaticArrays
using MeshCore.Exports
using MeshSteward.Exports
using Elfel.Exports
using UnicodePlots</code></pre><p>The boundary value problem is expressed in this weak form</p><div>\[\int_{\Omega} \left(2\mu\frac{\partial{w_x}}{\partial{x}}\frac{\partial{u_x}}{\partial{x}}
+\mu\frac{\partial{w_x}}{\partial{y}}\left(\frac{\partial{u_x}}{\partial{y}}+\frac{\partial{u_y}}{\partial{x}}\right)  - \frac{\partial{w_x}}{\partial{x}} p \right) d\Omega  = 0\]</div><div>\[\int_{\Omega} \left(2\mu\frac{\partial{w_y}}{\partial{y}}\frac{\partial{u_y}}{\partial{y}}
+\mu\frac{\partial{w_y}}{\partial{x}}\left(\frac{\partial{u_x}}{\partial{y}}+\frac{\partial{u_y}}{\partial{x}}\right)  - \frac{\partial{w_y}}{\partial{y}} p \right) d\Omega  = 0\]</div><div>\[-\int_{\Omega} q \left(\frac{\partial{u_x}}{\partial{x}} + \frac{\partial{u_y}}{\partial{y}}\right)d\Omega = 0\]</div><p>Here <span>$w_x, w_y$</span> are the test functions in the velocity space, and <span>$q$</span> is the pressure test functions. Further <span>$u_x, u_y$</span> is the trial velocity, and <span>$p$</span> is the trial pressure.</p><pre><code class="language-julia">function run()
    mu = 1.0 # dynamic viscosity
    A = 1.0 # half of the length of the side of the square
    N = 100 # number of element edges per side of the square</code></pre><p>These three functions define the true velocity components and the true pressure.</p><pre><code class="language-julia">    trueux = (x, y) -&gt; 20 * x * y ^ 3
    trueuy = (x, y) -&gt; 5 * x ^ 4 - 5 * y ^ 4
    truep = (x, y) -&gt; 60 * x ^ 2 * y - 20 * y ^ 3</code></pre><p>Construct the two meshes for the mixed method. They need to support the velocity and pressure spaces.</p><pre><code class="language-julia">    vmesh, pmesh = genmesh(A, N)</code></pre><p>Construct the velocity spaces: As an alternative to a previous treatment with a single vector space for the velocity, here we will use to vector spaces, one for each component of the velocity. The degrees of freedom are real numbers (<code>Float64</code>). The velocity mesh carries the finite elements of  the continuity <span>$H ^1$</span>, i. e. both the function values and the derivatives are square integrable. Each node carries just one degree of freedom (1).</p><pre><code class="language-julia">    Uxh = FESpace(Float64, vmesh, FEH1_T6(), 1)
    Uyh = FESpace(Float64, vmesh, FEH1_T6(), 1)</code></pre><p>Now we apply the boundary conditions at the nodes around the circumference.</p><pre><code class="language-julia">    locs = geometry(vmesh)</code></pre><p>We use searching based on the presence of the node within a box. The entire boundary will be captured within these four boxes, provided we inflate those boxes with a little tolerance (we can&#39;t rely on those nodes to be precisely at the coordinates given, we need to introduce some tolerance).</p><pre><code class="language-julia">    boxes = [[-A A -A -A], [-A -A -A A], [A A -A A], [-A A A A]]
    inflate = A / N / 100
    for box in boxes
        vl = vselect(locs; box = box, inflate = inflate)
        for i in vl</code></pre><p>Remember that all  components of the velocity are known at the boundary.</p><pre><code class="language-julia">            setebc!(Uxh, 0, i, 1, trueux(locs[i]...))
            setebc!(Uyh, 0, i, 1, trueuy(locs[i]...))
        end
    end</code></pre><p>No we construct the pressure space. It is a continuous, piecewise linear space supported on a mesh of three-node triangles.</p><pre><code class="language-julia">    Ph = FESpace(Float64, pmesh, FEH1_T3(), 1)</code></pre><p>The pressure in this &quot;enclosed&quot; flow example is only known up to a constant. By setting  pressure degree of freedom at one node will make the solution unique.</p><pre><code class="language-julia">    atcenter = vselect(geometry(pmesh); nearestto = [0.0, 0.0])
    setebc!(Ph, 0, atcenter[1], 1, 0.0)</code></pre><p>Number the degrees of freedom. First all the free degrees of freedom are numbered, both velocities and pressures. Next all the data degrees of freedom are numbered, again both for the velocities and for the pressures.</p><pre><code class="language-julia">    numberdofs!([Uxh, Uyh, Ph])</code></pre><p>The total number of degrees of freedom is now calculated.</p><pre><code class="language-julia">    tndof = ndofs(Uxh) + ndofs(Uyh) + ndofs(Ph)</code></pre><p>As is the total number of unknowns.</p><pre><code class="language-julia">    tnunk = nunknowns(Uxh) + nunknowns(Uyh) + nunknowns(Ph)</code></pre><p>Assemble the coefficient matrix.</p><pre><code class="language-julia">    K = assembleK(Uxh, Uyh, Ph, tndof, mu)</code></pre><p>Display the structure of the indefinite stiffness matrix. Note that this is the complete matrix, including rows and columns for all the degrees of freedom, unknown and known.</p><pre><code class="language-julia">    p = spy(K, canvas = DotCanvas)
    display(p)</code></pre><p>Solve the linear algebraic system. First construct system vector of all the degrees of freedom, in the first <code>tnunk</code> rows that corresponds to the unknowns, and the subsequent rows are for the data degrees of freedom.</p><pre><code class="language-julia">    U = fill(0.0, tndof)
    gathersysvec!(U, [Uxh, Uyh, Ph])</code></pre><p>Note that  the vector <code>U</code> consists of nonzero numbers in rows are for the data degrees of freedom. Multiplying the stiffness matrix with this vector will generate a load vector  on the right-hand side. Otherwise there is no loading, hence the vector <code>F</code> consists of all zeros.</p><pre><code class="language-julia">    F = fill(0.0, tndof)
    solve!(U, K, F, tnunk)</code></pre><p>Once we have solved the system of linear equations, we can distribute the solution from the vector <code>U</code> into the finite element spaces.</p><pre><code class="language-julia">    scattersysvec!([Uxh, Uyh, Ph], U)</code></pre><p>Given that the solution is manufactured, i. e. exactly known, we can calculate the true errors.</p><pre><code class="language-julia">    @show ep = evaluate_pressure_error(Ph, truep)
    @show ev = evaluate_velocity_error(Uxh, Uyh, trueux, trueuy)</code></pre><p>Postprocessing. First we make attributes, scalar nodal attributes, associated with the meshes for the pressures and the velocity.</p><pre><code class="language-julia">    makeattribute(Ph, &quot;p&quot;, 1)
    makeattribute(Uxh, &quot;ux&quot;, 1)
    makeattribute(Uyh, &quot;uy&quot;, 1)</code></pre><p>The pressure and the velocity components are then written out into two VTK files.</p><pre><code class="language-julia">    vtkwrite(&quot;tut_stokes_ht_p2_p1_reddy-p&quot;, baseincrel(pmesh), [(name = &quot;p&quot;,), ])
    vtkwrite(&quot;tut_stokes_ht_p2_p1_reddy-v&quot;, baseincrel(vmesh), [(name = &quot;ux&quot;,), (name = &quot;uy&quot;,)])

    return true
end

function genmesh(A, N)</code></pre><p>Hood-Taylor pair of meshes is needed. The first mesh is for the velocities, composed of six-node triangles.</p><pre><code class="language-julia">    vmesh = attach!(Mesh(), T6block(2 * A, 2 * A, N, N), &quot;velocity&quot;)</code></pre><p>Now translate so that the center of the square is at the origin of the coordinates.</p><pre><code class="language-julia">    ir = baseincrel(vmesh)
    transform(ir, x -&gt; x .- A)</code></pre><p>The second mesh is used for the pressures, and it is composed of three-node triangles such that the corner nodes are shared between the first and the second mesh.</p><pre><code class="language-julia">    pmesh = attach!(Mesh(), T6toT3(baseincrel(vmesh, &quot;velocity&quot;)), &quot;pressure&quot;)</code></pre><p>Return the pair of meshes</p><pre><code class="language-julia">    return vmesh, pmesh
end


function assembleK(Uxh, Uyh, Ph, tndof, mu)</code></pre><p>Here we demonstrate that the coefficient matrix, which is expected to have the structure</p><div>\[K = \left[
\begin{array}{cc}
    A &amp; B^T \\
    B &amp; 0
\end{array}\right]\]</div><p>can be constructed in stages. Refer to the description below. The two functions below  carry out the integration of two separate parts of the coefficient matrix.</p><pre><code class="language-julia">    function integrateApart!(ass, elits, qpits, mu)
        uxnedof, uynedof, pnedof = ndofsperel.(elits)
        kuxux = LocalMatrixAssembler(uxnedof, uxnedof, 0.0)
        kuyuy = LocalMatrixAssembler(uynedof, uynedof, 0.0)
        kuxuy = LocalMatrixAssembler(uxnedof, uynedof, 0.0)
        for el in zip(elits...)
            uxel, uyel, pel = el
            init!(kuxux, eldofs(uxel), eldofs(uxel))
            init!(kuyuy, eldofs(uyel), eldofs(uyel))
            init!(kuxuy, eldofs(uxel), eldofs(uyel))
            for qp in zip(qpits...)</code></pre><p>Step the quadrature point iterators in step: this assumes that in fact there is the same number of quadrature points in all the quadrature rules.</p><pre><code class="language-julia">                uxqp, uyqp, pqp = qp
                Jac, J = jacjac(pel, pqp)
                JxW = J * weight(pqp)</code></pre><p>Note that the gradients of the basis functions are not necessarily the same in those two velocity spaces. Hence we must grab the gradient from the correct space.</p><pre><code class="language-julia">                gradNux = bfungrad(uxqp, Jac)
                gradNuy = bfungrad(uyqp, Jac)
                for j in 1:uxnedof, i in 1:uxnedof
                    kuxux[i, j] += (mu * JxW) * (2 * gradNux[i][1] * gradNux[j][1] + gradNux[i][2] * gradNux[j][2])
                end
                for j in 1:uynedof, i in 1:uynedof
                    kuyuy[i, j] += (mu * JxW) * (gradNuy[i][1] * gradNuy[j][1] + 2 * gradNuy[i][2] * gradNuy[j][2])
                end
                for j in 1:uynedof, i in 1:uxnedof
                    kuxuy[i, j] += (mu * JxW) * (gradNux[i][1] * gradNuy[j][2])
                end
            end
            assemble!(ass, kuxux)
            assemble!(ass, kuxuy) # off-diagonal matrix needs to be assembled twice
            assemble!(ass, transpose(kuxuy))
            assemble!(ass, kuyuy)
        end
        return ass
    end
    function integrateBBTparts!(ass, elits, qpits)
        uxnedof, uynedof, pnedof = ndofsperel.(elits)
        kuxp = LocalMatrixAssembler(uxnedof, pnedof, 0.0)
        kuyp = LocalMatrixAssembler(uynedof, pnedof, 0.0)
        for el in zip(elits...)</code></pre><p>The iterators of the finite elements are stepped in unison.</p><pre><code class="language-julia">            uxel, uyel, pel = el</code></pre><p>Initialize the local matrix assembler with the global degree of freedom numbers, both for the velocity spaces and for the pressure space.</p><pre><code class="language-julia">            init!(kuxp, eldofs(uxel), eldofs(pel))
            init!(kuyp, eldofs(uyel), eldofs(pel))
            for qp in zip(qpits...)</code></pre><p>Step the quadrature point iterators in step: this assumes that in fact there is the same number of quadrature points in all the quadrature rules.</p><pre><code class="language-julia">                uxqp, uyqp, pqp = qp
                Jac, J = jacjac(pel, pqp)
                JxW = J * weight(pqp)
                gradNux = bfungrad(uxqp, Jac)
                gradNuy = bfungrad(uyqp, Jac)
                Np = bfun(pqp)
                for j in 1:pnedof, i in 1:uxnedof
                    kuxp[i, j] += (-JxW) * (gradNux[i][1] * Np[j])
                end
                for j in 1:pnedof, i in 1:uynedof
                    kuyp[i, j] += (-JxW) * (gradNuy[i][2] * Np[j])
                end
            end
            assemble!(ass, kuxp)
            assemble!(ass, transpose(kuxp))
            assemble!(ass, kuyp)
            assemble!(ass, transpose(kuyp))
        end
        return ass
    end</code></pre><p>In the <code>assembleK</code> function we first we create the element iterators. We can go through all the elements, both in the velocity finite element space and in the pressure finite element space, that define the domain of integration using this iterator. Each time a new element is accessed, some data are precomputed such as the element degrees of freedom, components of the degree of freedom, etc. Note that we need to iterate two finite element spaces, hence we create a tuple of iterators.</p><pre><code class="language-julia">    elits = (FEIterator(Uxh), FEIterator(Uyh), FEIterator(Ph))</code></pre><p>These are the quadrature point iterators. We know that the elements are triangular. We choose the three-point rule, to capture the quadratic component in the velocity space. Quadrature-point iterators provide access to basis function values and gradients, the Jacobian matrix and the Jacobian determinant, the location of the quadrature point and so on. Note that we need to iterate the quadrature rules of three finite element spaces, hence we create a tuple of iterators. All of these quadrature point iterators refer to the &quot;same&quot; quadrature rule: the same number of quadrature points, the same weights, and so on. However, the services these quadrature points provide do depend on the finite element space as well, for instance they would typically have different basis functions.</p><pre><code class="language-julia">    qargs = (kind = :default, npts = 3,)
    qpits = (QPIterator(Uxh, qargs), QPIterator(Uyh, qargs), QPIterator(Ph, qargs))</code></pre><p>The matrix will be assembled into this assembler. Which is initialized with the total number of degrees of freedom (dimension of the coefficient matrix before partitioning into unknowns and data degrees of freedom).</p><pre><code class="language-julia">    ass = SysmatAssemblerSparse(0.0)
    start!(ass, tndof, tndof)</code></pre><p>First we calculate the &quot;A&quot; part, using the function below. It is &quot;assembled&quot; into the assembler, which means that after this function finishes, the assembler represents this intermediate matrix</p><div>\[K = \left[
\begin{array}{cc}
    A &amp; 0 \\
    0 &amp; 0
\end{array}\right]\]</div><pre><code class="language-julia">    integrateApart!(ass, elits, qpits, mu)</code></pre><p>Then the &quot;B-transpose(B)&quot; part using this function is added to the assembler. When the function below finishes, the assembler represents the entire <span>$K$</span> matrix.</p><pre><code class="language-julia">    integrateBBTparts!(ass, elits, qpits)</code></pre><p>Finally, we materialize the sparse stiffness matrix from the assembler and return it.</p><pre><code class="language-julia">    return finish!(ass)
end</code></pre><p>The linear algebraic system is solved by partitioning. The vector <code>U</code> is initially all zero, except in the degrees of freedom which are prescribed as nonzero. Therefore the product of the stiffness matrix and the vector <code>U</code> are the loads due to nonzero essential boundary conditions.  The submatrix of the stiffness conduction matrix corresponding to the free degrees of freedom (unknowns), <code>K[1:nu, 1:nu]</code> is then used to solve for the unknowns <code>U [1:nu]</code>.</p><pre><code class="language-julia">function solve!(U, K, F, nu)
    KT = K * U
    U[1:nu] = K[1:nu, 1:nu] \ (F[1:nu] - KT[1:nu])
end</code></pre><p>The function <code>evaluate_pressure_error</code> evaluates the true <span>$L^2$</span>  error of the pressure. It does that by integrating the square of the difference between the approximate pressure and the  true pressure, the true pressure being provided by the <code>truep</code> function.</p><pre><code class="language-julia">function evaluate_pressure_error(Ph, truep)
    function integrate!(elit, qpit, truep)
        n_dp = ndofsperel(elit)
        E = 0.0
        for el in elit
            dofvals = eldofvals(el)
            for qp in qpit
                Jac, J = jacjac(el, qp)
                JxW = J * weight(qp)
                Np = bfun(qp)
                pt = truep(location(el, qp)...)
                pa = 0.0
                for j in 1:n_dp
                    pa += (dofvals[j] * Np[j])
                end
                E += (JxW) * (pa - pt)^2
            end
        end
        return sqrt(E)
    end

    elit = FEIterator(Ph)
    qargs = (kind = :default, npts = 3,)
    qpit = QPIterator(Ph, qargs)
    return integrate!(elit, qpit, truep)
end</code></pre><p>The function <code>evaluate_velocity_error</code> evaluates the true <span>$L^2$</span>  error of the velocity. It does that by integrating the square of the difference between the approximate pressure and the  true velocity, the true velocity being provided by the <code>trueux</code>, <code>trueuy</code> functions.</p><pre><code class="language-julia">function evaluate_velocity_error(Uxh, Uyh, trueux, trueuy)
    function integrate!(elits, qpits, trueux, trueuy)
        n_du, n_du = ndofsperel.(elits)
        E = 0.0
        for el in zip(elits...)
            uxel, uyel = el
            uxdofvals = eldofvals(uxel)
            uydofvals = eldofvals(uyel)
            for qp in zip(qpits...)
                uxqp, uyqp = qp
                Jac, J = jacjac(uxel, uxqp)
                JxW = J * weight(uxqp)
                Nu = bfun(uxqp)
                uxt = trueux(location(uxel, uxqp)...)
                uyt = trueuy(location(uxel, uxqp)...)
                uxa = 0.0
                uya = 0.0
                for j in 1:n_du
                    uxa += (uxdofvals[j] * Nu[j])
                    uya += (uydofvals[j] * Nu[j])
                end
                E += (JxW) * ((uxa - uxt)^2 + (uya - uyt)^2)
            end
        end
        return sqrt(E)
    end

    elits = (FEIterator(Uxh), FEIterator(Uyh),)
    qargs = (kind = :default, npts = 3,)
    qpits = (QPIterator(Uxh, qargs), QPIterator(Uyh, qargs),)
    return integrate!(elits, qpits, trueux, trueuy)
end

end</code></pre><p>To run the example, evaluate this file which will  compile the module <code>.tut_stokes_ht_p2_p1_reddy</code>.</p><pre><code class="language-julia">using .tut_stokes_ht_p2_p1_reddy
tut_stokes_ht_p2_p1_reddy.run()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 September 2020 19:22">Tuesday 15 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
